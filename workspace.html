<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AlphaLine | Workspace</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&family=JetBrains+Mono:wght@300&display=swap');
        
        :root { 
            --bg: #000; 
            --ui-bg: #1a1a1a; 
            --text-primary: #fff;
            --text-dim: #bbb; 
            --accent: #fff; 
            --danger: #ff4444; 
            --border: #444;
            --grid-line: rgba(255, 255, 255, 0.12);
            --node-bg: rgba(25, 25, 25, 0.85);
            --node-border: rgba(255, 255, 255, 0.2);
            --panel-bg: rgba(20, 20, 20, 0.9);
            --hud-bg: #1a1a1a;
            --hud-text: #fff;
            --hud-border: #333;
            --pipe-color: rgba(255, 255, 255, 0.25);
        }

        /* Light Mode - Everything Light */
        body.theme-light {
            --bg: #f5f5f5;
            --ui-bg: #fff;
            --text-primary: #1a1a1a;
            --text-dim: #666;
            --border: #ddd;
            --grid-line: rgba(0, 0, 0, 0.06);
            --node-bg: rgba(255, 255, 255, 0.95);
            --node-border: rgba(0, 0, 0, 0.1);
            --panel-bg: rgba(255, 255, 255, 0.95);
            --hud-bg: #fff;
            --hud-text: #1a1a1a;
            --hud-border: #ddd;
            --pipe-color: rgba(0, 0, 0, 0.15);
        }

        /* Dark on Light - Light background, Dark nodes */
        body.theme-dark-on-light {
            --bg: #f5f5f5;
            --ui-bg: #fff;
            --text-primary: #fff;
            --text-dim: #bbb;
            --border: #333;
            --grid-line: rgba(0, 0, 0, 0.06);
            --node-bg: rgba(15, 15, 15, 0.75);
            --node-border: rgba(255, 255, 255, 0.15);
            --panel-bg: rgba(12, 12, 12, 0.85);
            --hud-bg: #0a0a0a;
            --hud-text: #fff;
            --hud-border: #222;
            --pipe-color: rgba(0, 0, 0, 0.3);
        }

        /* Light on Dark - Dark background, Light nodes */
        body.theme-light-on-dark {
            --bg: #000;
            --ui-bg: #0d0d0d;
            --text-primary: #1a1a1a;
            --text-dim: #666;
            --border: #ddd;
            --grid-line: rgba(255, 255, 255, 0.08);
            --node-bg: rgba(255, 255, 255, 0.95);
            --node-border: rgba(0, 0, 0, 0.1);
            --panel-bg: rgba(12, 12, 12, 0.85);
            --hud-bg: #fff;
            --hud-text: #1a1a1a;
            --hud-border: #ddd;
            --pipe-color: rgba(200, 200, 200, 0.4);
        }

        /* Apply colors to elements */
        body.theme-light #grid-year-display,
        body.theme-light .plot-title-field,
        body.theme-light .episode-title-input,
        body.theme-light .synopsis-input,
        body.theme-light .event-input,
        body.theme-light-on-dark #grid-year-display,
        body.theme-light-on-dark .plot-title-field,
        body.theme-light-on-dark .episode-title-input,
        body.theme-light-on-dark .synopsis-input,
        body.theme-light-on-dark .event-input {
            color: #1a1a1a;
        }

        /* Light-on-Dark: Override backgrounds to match Light mode */
        body.theme-light-on-dark .plot-title-field,
        body.theme-light-on-dark .episode-title-input,
        body.theme-light-on-dark .synopsis-input,
        body.theme-light-on-dark .event-input {
            background: rgba(255, 255, 255, 0.95);
        }

        /* Light-on-Dark: Override node backgrounds */
        body.theme-light-on-dark .plot-node,
        body.theme-light-on-dark .event-node,
        body.theme-light-on-dark .synopsis-node,
        body.theme-light-on-dark .event-text-container {
            background: rgba(255, 255, 255, 0.95);
        }

        body.theme-light .node-label,
        body.theme-light-on-dark .node-label {
            color: #555;
        }

        body.theme-light .episode-title-input::placeholder,
        body.theme-light .synopsis-input::placeholder,
        body.theme-light .event-input::placeholder,
        body.theme-light-on-dark .episode-title-input::placeholder,
        body.theme-light-on-dark .synopsis-input::placeholder,
        body.theme-light-on-dark .event-input::placeholder {
            color: #aaa;
        }

        body.theme-light .char-count,
        body.theme-light-on-dark .char-count {
            color: #999;
        }

        /* Light mode timeline dot shadows */
        body.theme-light .year-dot,
        body.theme-light-on-dark .year-dot {
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.4));
        }

        /* Light mode project name colors */
        body.theme-light #project-name-display,
        body.theme-light-on-dark #project-name-display {
            color: #888 !important;
        }

        body.theme-light #project-name-display span,
        body.theme-light-on-dark #project-name-display span {
            color: #555 !important;
        }
        
        html, body { 
            margin: 0; padding: 0; height: 100vh; width: 100vw; 
            background: var(--bg); color: #fff; 
            font-family: 'Inter', sans-serif; overflow: hidden;
            user-select: none;
        }

        /* --- HEADER --- */
        .workspace-header {
            position: fixed; top: 0; left: 0; width: 100%; height: 65px;
            background: var(--hud-bg); 
            border-bottom: 1px solid var(--hud-border);
            display: flex; align-items: center; padding: 0 2rem; box-sizing: border-box; z-index: 2000;
        }
        .brand-block { display: flex; align-items: center; gap: 15px; }
        .back-btn { cursor: pointer; color: var(--text-dim); font-size: 1.2rem; transition: 0.2s; width: 30px; text-align: center; }
        .back-btn:hover { color: var(--hud-text); }
        .nav-text { font-size: 0.7rem; letter-spacing: 3px; text-transform: uppercase; color: var(--text-dim); display:flex; gap:10px; align-items: center; }
        .nav-text strong { color: var(--hud-text); font-weight: 800; }
        
        .status-block { margin-left: auto; display: flex; align-items: center; gap: 30px; text-align: right; }
        .save-indicator { font-size: 0.6rem; color: #444; letter-spacing: 1px; font-weight: 600; }
        .clock-block { font-family: 'JetBrains Mono', monospace; font-size: 0.65rem; color: var(--text-dim); line-height: 1.3; }

        /* --- MODALS & LIGHTBOX --- */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); backdrop-filter: blur(5px);
            display: none; justify-content: center; align-items: center; z-index: 3000;
        }
        .modal-content { 
            background: #080808; 
            border: 1px solid #333; 
            padding: 30px; 
            width: 300px; 
            text-align: center; 
            display:flex; 
            flex-direction:column; 
            gap:20px; 
            box-shadow: 0 20px 50px rgba(0,0,0,0.8); 
        }
        .modal-title {
            font-size: 0.65rem;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        .modal-input { 
            background: #111; 
            border: 1px solid #333; 
            color: #fff; 
            padding: 10px; 
            font-family: 'JetBrains Mono'; 
            text-align: center; 
            outline: none; 
            font-size: 1.2rem; 
        }
        
        /* Lightbox specific */
        #lightbox-img-container { display: flex; flex-direction: column; align-items: center; gap: 20px; max-width: 90vw; max-height: 90vh; }
        #lightbox-img { max-width: 100%; max-height: 80vh; border: 1px solid #333; box-shadow: 0 0 50px rgba(0,0,0,0.8); object-fit: contain; }
        .lightbox-controls { display: flex; gap: 15px; }

        /* --- TRASH ZONE --- */
        #trash-zone {
            position: fixed; bottom: 30px; left: 30px; width: 60px; height: 60px;
            border: 2px dashed #444; border-radius: 50%; color: #444;
            display: flex; align-items: center; justify-content: center;
            font-size: 24px; z-index: 2500; transition: 0.3s;
            opacity: 0; pointer-events: none; background: rgba(0,0,0,0.5);
        }
        body.global-dragging #trash-zone { opacity: 1; pointer-events: all; }
        #trash-zone.drag-over { border-color: var(--danger); color: var(--danger); background: rgba(255, 68, 68, 0.1); transform: scale(1.1); }

        /* --- PLANE & GRID --- */
        #plane-container { 
            width: 100vw; height: calc(100vh - 65px); margin-top: 65px;
            background-color: var(--bg);
            background-image: linear-gradient(var(--grid-line) 1px, transparent 1px), linear-gradient(90deg, var(--grid-line) 1px, transparent 1px);
            background-size: 20px 20px; position: relative; overflow: hidden; cursor: crosshair;
        }
        #node-group {
            position: absolute; 
            left: 50%; 
            top: 50%; 
            display: none; 
            flex-direction: column; 
            align-items: center; 
            transform: translate(-50%, -50%);
            transform-origin: center center;
            z-index: 100;
        }

        /* --- NODES --- */
        .grid-node { 
            padding: 20px 40px; 
            background: var(--node-bg);
            backdrop-filter: blur(12px); 
            border: 2px solid var(--node-border);
            display: flex; 
            flex-direction: column; 
            align-items: center;
            position: relative;
            cursor: pointer;
            transition: all 0.5s ease;
            overflow: hidden;
        }
        
        .grid-node.has-banner {
            width: 800px;
            height: 300px;
            padding: 0;
            justify-content: center;
        }
        
        .grid-node-banner {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            filter: blur(4px) brightness(0.5);
            transition: filter 0.3s ease;
            z-index: 0;
        }
        
        /* Light mode - only blur, no brightness change */
        body.theme-light .grid-node-banner,
        body.theme-light-on-dark .grid-node-banner {
            filter: blur(4px);
        }
        
        body.theme-light .grid-node.has-banner:hover .grid-node-banner,
        body.theme-light-on-dark .grid-node.has-banner:hover .grid-node-banner {
            filter: blur(0px);
        }
        
        .grid-node.has-banner:hover {
            box-shadow: 0 0 40px rgba(100, 200, 255, 0.6), 
                        0 0 80px rgba(100, 200, 255, 0.3),
                        0 0 120px rgba(100, 200, 255, 0.1);
        }
        
        .grid-node.has-banner:hover .grid-node-banner {
            filter: blur(0px) brightness(1);
        }
        
        .grid-node-content {
            position: relative;
            z-index: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: opacity 0.3s ease;
        }
        
        .grid-node.has-banner:hover .grid-node-content {
            opacity: 0;
        }
        
        .grid-node h2 { 
            font-family: 'JetBrains Mono'; 
            font-size: 3rem; 
            margin: 0; 
            letter-spacing: 6px; 
            font-weight: 300; 
            color: var(--text-primary);
            text-align: center;
            min-width: 120px;
            transition: font-size 0.2s ease;
        }
        .grid-node h2.shrink { 
            font-size: 2rem; 
            letter-spacing: 3px;
        }
        .node-label { font-size: 0.55rem; color: #888; letter-spacing: 4px; font-weight: 800; margin-bottom: 8px; text-transform: uppercase; }
        
        /* Landing message */
        #landing-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Roboto', 'Inter', sans-serif;
            font-size: 1.5rem;
            font-weight: 300;
            text-align: center;
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.8),
                         0 0 40px rgba(255, 255, 255, 0.4),
                         0 2px 4px rgba(0, 0, 0, 0.5);
            z-index: 2000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        
        #landing-message.visible {
            opacity: 1;
        }
        
        /* Light theme adjustments */
        body.theme-light #landing-message,
        body.theme-light-on-dark #landing-message {
            color: rgba(0, 0, 0, 0.85);
            text-shadow: 0 0 20px rgba(255, 255, 255, 1),
                         0 0 40px rgba(255, 255, 255, 0.8),
                         0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        /* Timeline glow animation */
        #timeline-hud.glow-pulse {
            animation: timelineGlow 2s ease-in-out infinite;
        }
        
        @keyframes timelineGlow {
            0%, 100% {
                filter: drop-shadow(0 0 10px rgba(100, 200, 255, 0.3));
            }
            50% {
                filter: drop-shadow(0 0 30px rgba(100, 200, 255, 0.8))
                        drop-shadow(0 0 60px rgba(100, 200, 255, 0.4));
            }
        }
        
        .episode-title-input {
            background: transparent;
            border: none;
            border-bottom: 2px solid var(--border);
            color: var(--text-dim);
            font-family: 'Inter', sans-serif;
            font-size: 0.9rem;
            text-align: center;
            outline: none;
            padding: 15px 20px;
            margin-top: 12px;
            width: 180px;
            transition: 0.2s;
        }

        .episode-title-input:focus {
            border-bottom-color: var(--text-dim);
            color: var(--text-primary);
        }

        .episode-title-input::placeholder {
            color: #444;
        }
        
        .sub-node { 
            padding: 20px 40px; 
            background: var(--node-bg);
            backdrop-filter: blur(8px); 
            border: 2px solid var(--node-border);
            border-radius: 50px; 
            text-align: center; 
            width: 280px;
            cursor: pointer;
            transition: border-color 0.3s ease, box-shadow 0.3s ease, background 0.3s ease;
            transform-origin: center center;
            position: relative;
            left: 0;
        }
        
        .sub-node:hover {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.2), 0 0 40px rgba(255, 255, 255, 0.1);
            background: rgba(15, 15, 15, 0.8);
            animation: pulseInPlace 1.5s ease-in-out infinite;
        }
        
        @keyframes pulseInPlace {
            0%, 100% { 
                transform: scale(1);
            }
            50% { 
                transform: scale(1.02);
            }
        }

        .synopsis-node { 
            width: 500px; 
            background: var(--panel-bg);
            border: 2px solid var(--border);
            border-radius: 8px; 
            padding: 20px; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
        }
        .synopsis-input { 
            width: 100%; 
            background: transparent; 
            border: none; 
            color: var(--text-primary);
            font-family: 'Inter', sans-serif; 
            font-size: 0.85rem; 
            line-height: 1.5; 
            resize: none; 
            outline: none; 
            text-align: center; 
            overflow: hidden;
            white-space: pre-wrap;
            word-wrap: break-word;
            min-height: 60px;
        }
        
        /* Contenteditable placeholder */
        .synopsis-input[contenteditable]:empty:before {
            content: attr(placeholder);
            color: #444;
            cursor: text;
        }

        /* Pipes */
        .node-pipe { 
            width: 2px; 
            height: 40px; 
            background: var(--pipe-color);
            position: relative; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
        }
        .pipe-add { 
            position: absolute; 
            width: 22px; 
            height: 22px; 
            border-radius: 50%; 
            background: var(--node-bg);
            border: 2px solid var(--node-border);
            color: var(--text-primary);
            font-size: 14px; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            cursor: pointer; 
            opacity: 0; 
            transition: 0.2s; 
            z-index: 10; 
            transform: scale(0.8); 
        }
        .node-pipe:hover .pipe-add, .branch-hub:hover .pipe-add { opacity: 1; transform: scale(1); }

        /* Branch Hub */
        .branch-hub { display: flex; align-items: center; justify-content: center; position: relative; height: 40px; width: 100%; }
        .hub-center-line { 
            width: 2px; 
            height: 100%; 
            background: var(--pipe-color);
            position: relative; 
            display:flex; 
            justify-content:center; 
            align-items:center; 
        }
        .hub-arm { 
            width: 0px; 
            height: 2px; 
            background: var(--pipe-color);
            transition: 0.3s; 
            position: relative; 
        }
        .hub-trigger { 
            width: 20px; 
            height: 20px; 
            border-radius: 50%; 
            background: var(--node-bg);
            border: 2px solid var(--node-border);
            color: var(--text-primary);
            display: flex; 
            align-items: center; 
            justify-content: center; 
            font-size: 12px; 
            cursor: pointer; 
            position: absolute; 
            top: 50%; 
            transform: translateY(-50%); 
            opacity: 0; 
            transition:0.2s;
        }
        .branch-hub.active .hub-arm { width: 450px; }
        .branch-hub.active .hub-trigger { opacity: 0; transition: opacity 0.3s; }
        .branch-hub.active:hover .hub-trigger { opacity: 1; }
        .branch-hub.active .pipe-add { opacity: 0; transition: opacity 0.3s; }
        .branch-hub.active:hover .pipe-add { opacity: 1; }
        .trigger-left { left: 0; transform: translate(-50%, -50%); }
        .trigger-right { right: 0; transform: translate(50%, -50%); }

        /* --- PLOT COLUMNS --- */
        #plot-grid-container {
            display: flex; align-items: flex-start; gap: 60px; justify-content: center;
            width: max-content; 
            min-width: 100%;
        }
        
        /* Plot Grid System */
        .plot-grid {
            display: grid;
            grid-template-columns: repeat(3, 1100px);
            gap: 30px;
            row-gap: 60px;
            margin-top: 30px;
            padding: 20px;
            position: relative;
        }
        
        .plot-grid.hide-empty-cells .grid-cell.empty {
            background: transparent !important;
            border-color: transparent !important;
        }
        
        .plot-grid.hide-empty-cells .grid-cell {
            background: transparent !important;
            border-color: transparent !important;
        }
        
        .plot-grid.hide-empty-cells .grid-cell.empty .grid-add-btn {
            opacity: 0 !important;
        }
        
        .plot-grid.hide-empty-cells .grid-cell.empty .grid-helper-text {
            opacity: 0 !important;
        }
        
        .grid-cell {
            min-height: 150px;
            border: 2px solid rgba(255, 255, 255, 0.15);
            border-radius: 15px;
            transition: background 0.4s ease, border-color 0.4s ease;
            position: relative;
            display: flex;
            align-items: flex-start;
            justify-content: center;
            background: rgba(0, 0, 0, 0.3);
        }
        
        .grid-cell.empty {
            background: rgba(0, 0, 0, 0.15);
            border-color: rgba(255, 255, 255, 0.06);
            cursor: pointer;
            align-items: center;
        }
        
        .grid-cell.empty:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.3);
        }
        
        .grid-add-btn {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3.5rem;
            color: rgba(255, 255, 255, 0.1);
            transition: color 0.4s ease, transform 0.4s ease;
            pointer-events: none;
            user-select: none;
            font-weight: 300;
        }
        
        .grid-cell.empty:hover .grid-add-btn {
            color: rgba(255, 255, 255, 0.6);
            transform: translate(-50%, -50%) scale(1.2);
        }
        
        .grid-helper-text {
            position: absolute;
            top: 65%;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.75rem;
            color: rgba(180, 180, 180, 0.7);
            text-align: center;
            pointer-events: none;
            user-select: none;
            white-space: nowrap;
            animation: helperPulse 2s ease-in-out infinite;
            font-weight: 500;
            letter-spacing: 1px;
        }
        
        /* Light theme - darker gray */
        body.theme-light .grid-helper-text {
            color: rgba(80, 80, 80, 0.7);
        }
        
        body.theme-light-on-dark .grid-helper-text {
            color: rgba(80, 80, 80, 0.7);
        }
        
        @keyframes helperPulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }
        
        .arrow-list-item {
            padding: 10px;
            margin-bottom: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            user-select: none;
        }
        
        .arrow-list-item:hover {
            background: rgba(255, 255, 255, 0.05);
            border-color: rgba(255, 255, 255, 0.2);
        }
        
        .arrow-list-item.selected {
            background: rgba(100, 200, 255, 0.2);
            border-color: rgba(100, 200, 255, 0.5);
        }
        
        .arrow-list-item .arrow-from,
        .arrow-list-item .arrow-to {
            font-weight: bold;
            color: rgba(100, 200, 255, 1);
        }
        
        .arrow-list-item .arrow-arrow {
            color: var(--text-dim);
            margin: 0 8px;
        }
        
        .grid-cell.drag-over {
            background: rgba(100, 200, 255, 0.1);
            border-color: rgba(100, 200, 255, 0.5);
        }
        
        @keyframes gridPulse {
            0%, 100% { 
                background: rgba(255, 255, 255, 0.03);
                border-color: rgba(255, 255, 255, 0.15);
            }
            50% { 
                background: rgba(255, 255, 255, 0.1);
                border-color: rgba(255, 255, 255, 0.4);
            }
        }
        
        .grid-cell.empty.pulse-animation {
            animation: gridPulse 1.5s ease-in-out 3;
        }
        
        #grid-hover-tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid rgba(100, 200, 255, 0.5);
            border-radius: 6px;
            padding: 12px 16px;
            font-size: 0.75rem;
            color: rgba(100, 200, 255, 1);
            pointer-events: none;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.3s;
            white-space: nowrap;
            max-width: 300px;
        }
        
        #grid-hover-tooltip.show {
            opacity: 1;
        }

        /* --- PLOT & EVENT NODES --- */
        .plot-node-wrapper { 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            width: 100%; 
            cursor: grab;
            position: relative;
        }
        
        .plot-node-wrapper.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }
        
        .plot-connector {
            position: absolute;
            width: 24px;
            height: 24px;
            border: 3px solid rgba(100, 200, 255, 0.5);
            border-radius: 50%;
            background: var(--node-bg);
            cursor: pointer;
            z-index: 100;
            transition: all 0.2s ease;
        }
        
        .plot-connector:hover {
            border-color: rgba(100, 200, 255, 1);
            background: rgba(100, 200, 255, 0.2);
            transform: scale(1.3);
        }
        
        .plot-connector.top {
            top: -12px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .plot-connector.top:hover {
            transform: translateX(-50%) scale(1.3);
        }
        
        .plot-connector.bottom {
            bottom: -12px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .plot-connector.bottom:hover {
            transform: translateX(-50%) scale(1.3);
        }
        
        .plot-connector.drag-target {
            border-color: rgba(100, 255, 100, 1);
            background: rgba(100, 255, 100, 0.3);
            animation: pulse 0.8s infinite;
        }
        
        .plot-connector.has-arrows {
            border-color: rgba(255, 150, 50, 0.7);
        }
        
        .plot-connector.has-arrows:hover {
            border-color: rgba(255, 150, 50, 1);
        }
        
        @keyframes pulse {
            0%, 100% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.2); }
        }
        
        .plot-arrow {
            position: absolute;
            pointer-events: all;
            z-index: 5;
            cursor: pointer;
        }
        
        .plot-arrow line {
            stroke: rgba(100, 200, 255, 0.6);
            stroke-width: 2;
            marker-end: url(#arrowhead);
        }
        
        .plot-arrow:hover line {
            stroke: rgba(100, 200, 255, 1);
            stroke-width: 3;
        }
        
        .plot-node {
            width: 100%; 
            min-width: 754px;
            background: var(--panel-bg);
            border: 2px solid var(--border);
            border-radius: 15px; 
            padding: 25px; 
            box-sizing: border-box;
            display: flex; 
            flex-direction: column; 
            gap: 20px; 
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            transition: width 0.3s ease;
            position: relative;
        }
        
        .plot-lock-icon {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 24px;
            height: 24px;
            cursor: pointer;
            font-size: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-dim);
            transition: color 0.2s ease;
            z-index: 10;
        }
        
        .plot-lock-icon:hover {
            color: var(--text-primary);
        }
        
        .plot-node-wrapper.locked {
            cursor: not-allowed;
        }
        
        .plot-title-field {
            background: transparent; border: none; border-bottom: 2px solid var(--border); color: var(--text-primary); font-size: 0.9rem; letter-spacing: 3px; text-transform: uppercase;
            padding-bottom: 8px; outline: none; width: 100%; font-family: 'JetBrains Mono'; text-align: center;
        }
        
        .plot-title-field::placeholder {
            color: #444;
            opacity: 1;
        }
        
        .event-node {
            display: flex; 
            flex-direction: row; 
            background: var(--panel-bg);
            border: 2px solid var(--border);
            border-radius: 12px; 
            overflow: hidden; 
            position: relative; 
            width: 704px;
            max-width: 704px;
            margin: 0 auto;
            align-self: center;
            pointer-events: auto;
            z-index: 10;
        }
        .event-node.flipped { flex-direction: row-reverse; }
        
        .event-text-container { 
            flex: 0 0 562px;
            max-width: 562px;
            padding: 12px 16px; 
            position: relative; 
            display: flex; 
            flex-direction: column;
            min-height: 150px;
            overflow: hidden;
        }
        .event-input {
            background: transparent; border: none; color: var(--text-primary); resize: none; width: 100%; font-size: 0.85rem; line-height: 1.6; outline: none;
            font-family: 'Inter', sans-serif; min-height: 40px; display: block; overflow: hidden;
            word-wrap: break-word;
            overflow-wrap: break-word;
            white-space: pre-wrap;
            max-width: 100%;
            word-break: break-word;
        }
        
        /* Contenteditable placeholder for event input */
        .event-input[contenteditable]:empty:before {
            content: attr(placeholder);
            color: #444;
            cursor: text;
        }
        
        .char-count { font-size: 0.5rem; color: #444; text-align: right; margin-top: 5px; font-family: 'JetBrains Mono'; }

        .event-image-container {
            flex-shrink: 0; 
            background: var(--node-bg);
            border-left: 2px solid var(--border);
            cursor: pointer; 
            overflow: hidden; 
            display: flex; 
            justify-content: center; 
            align-items: center;
            position: relative;
            pointer-events: auto;
            z-index: 11;
        }

        .event-image-container img {
            display: block;
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
            object-fit: contain;
            object-position: center;
        }

        .event-node.flipped .event-image-container { border-left: none; border-right: 2px solid var(--border); }
        .event-image-container:hover img { opacity: 0.8; }
        .img-placeholder { padding: 10px; font-size: 0.5rem; color: #444; letter-spacing: 1px; text-align: center; position: absolute; }
        
        .event-image-upload-btn {
            position: absolute;
            top: 8px;
            left: 8px;
            background: var(--node-bg);
            border: 1px solid var(--border);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.5rem;
            color: var(--text-dim);
            cursor: pointer;
            transition: 0.2s;
            letter-spacing: 0.5px;
            font-weight: 600;
            z-index: 10;
        }
        
        .event-image-upload-btn.flipped {
            left: auto;
            right: 8px;
        }
        
        .event-image-upload-btn:hover {
            color: var(--text-primary);
            background: var(--border);
        }

        .event-tools {
            position: absolute; top: 8px; right: 8px; display: flex; gap: 6px; opacity: 0; transition: 0.2s;
            background: var(--node-bg);
            border: 1px solid var(--border);
            padding: 2px 4px; border-radius: 4px;
        }
        .event-node:hover .event-tools { opacity: 1; }
        .tool-btn {
            cursor: pointer; font-size: 10px; color: var(--text-dim); width: 16px; height: 16px; 
            display: flex; align-items: center; justify-content: center; border-radius: 3px;
        }
        .tool-btn:hover { 
            color: var(--text-primary);
            background: var(--border);
        }
        .tool-delete:hover { color: var(--danger); background: rgba(255, 68, 68, 0.1); }

        /* Event reorder arrows */
        .event-reorder {
            position: absolute;
            left: 8px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 8px;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 10;
        }
        .event-node:hover .event-reorder { opacity: 1; }
        .reorder-arrow {
            width: 0;
            height: 0;
            cursor: pointer;
            transition: 0.2s;
        }
        .reorder-arrow.up {
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 8px solid var(--text-dim);
        }
        .reorder-arrow.up:hover {
            border-bottom-color: var(--text-primary);
        }
        .reorder-arrow.down {
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 8px solid var(--text-dim);
        }
        .reorder-arrow.down:hover {
            border-top-color: var(--text-primary);
        }

        /* Event reorder arrows */
        .event-reorder {
            position: absolute;
            left: 8px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 4px;
            opacity: 0;
            transition: 0.2s;
        }
        .event-node:hover .event-reorder { opacity: 1; }
        .reorder-arrow {
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            cursor: pointer;
            transition: 0.2s;
        }
        .arrow-up {
            border-bottom: 8px solid var(--text-dim);
        }
        .arrow-up:hover {
            border-bottom-color: var(--text-primary);
        }
        .arrow-down {
            border-top: 8px solid var(--text-dim);
        }
        .arrow-down:hover {
            border-top-color: var(--text-primary);
        }

        /* Drag & Drop Styles */
        .draggable { cursor: grab; }
        .draggable:active { cursor: grabbing; }
        .dragging { opacity: 0.4; border: 1px dashed var(--accent) !important; }
        .drag-over { border: 1px solid var(--accent) !important; background: rgba(255,255,255,0.05); }

        /* --- TIMELINE HUD --- */
        #timeline-hud { 
            position: fixed; 
            left: 50%; 
            top: 80px; 
            transform: translateX(-50%); 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            gap: 2px; 
            z-index: 1500;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }
        
        #timeline-hud.hidden {
            transform: translateX(-50%) translateY(-130px);
            opacity: 0;
            pointer-events: none;
        }
        
        #timeline-toggle {
            position: fixed;
            left: 50%;
            top: 60px;
            transform: translateX(-50%);
            width: 60px;
            height: 20px;
            background: var(--hud-bg);
            border: 1px solid var(--hud-border);
            border-radius: 0 0 8px 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 1501;
            transition: all 0.3s ease;
            opacity: 0.6;
        }
        
        #timeline-toggle:hover {
            opacity: 1;
            background: rgba(30, 30, 30, 0.95);
        }
        
        .timeline-toggle-arrow {
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 8px solid var(--text-dim);
            transition: transform 0.3s ease;
        }
        
        #timeline-hud.hidden ~ #timeline-toggle .timeline-toggle-arrow {
            transform: rotate(180deg);
        }
        
        #timeline-bar { 
            width: 600px; 
            height: 40px; 
            background: var(--hud-bg);
            border: 1px solid var(--hud-border);
            border-radius: 4px; 
            position: relative; 
        }
        .timeline-axis { 
            position: absolute; 
            top: 50%; 
            left: 0; 
            width: 100%; 
            height: 1px; 
            background: var(--pipe-color);
            transform: translateY(-50%); 
        }
        
        /* Dark-on-Light: Make timeline more visible (light gray) */
        body.theme-dark-on-light .timeline-axis {
            background: rgba(180, 180, 180, 0.4);
        }
        
        /* Light-on-Dark: Make timeline more visible (darker) */
        body.theme-light-on-dark .timeline-axis {
            background: rgba(100, 100, 100, 0.6);
        }
        
        .year-dot, .year-line { cursor: pointer; position: absolute; top: 50%; transform: translate(-50%, -50%); transition: 0.2s; }
        .year-dot { 
            width: 12px; 
            height: 12px; 
            background: var(--text-dim);
            border: 2px solid var(--hud-bg);
            border-radius: 50%; 
            z-index: 20;
            cursor: pointer;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5));
            transition: 0.2s;
        }
        .year-dot:hover {
            transform: scale(1.2);
        }
        
        /* Selected timeline marker - black in Light modes */
        body.theme-light .selected-marker,
        body.theme-light-on-dark .selected-marker {
            background: #000 !important;
        }
        
        .year-line { 
            width: 2px; 
            height: 15px; 
            background: var(--text-dim);
            z-index: 10;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5));
        }
        .selected-marker { background: var(--accent) !important; box-shadow: 0 0 15px var(--accent); height: 20px !important; width: 2px !important; }
        
        .year-box { 
            position: absolute; 
            background: var(--hud-bg);
            border: 1px solid var(--hud-border);
            padding: 4px 8px; 
            font-family: 'JetBrains Mono'; 
            font-size: 0.6rem; 
            color: var(--hud-text);
            pointer-events: auto;
            cursor: pointer;
            transition: opacity 0.3s;
        }
        .box-min { right: 100%; margin-right: 15px; top: 50%; transform: translateY(-50%); }
        .box-max { left: 100%; margin-left: 15px; top: 50%; transform: translateY(-50%); }
        .box-above { 
            bottom: 100%; 
            margin-bottom: 10px; 
            left: 50%; 
            transform: translateX(-50%); 
            opacity: 0;
            pointer-events: none;
        }
        .box-above.show { 
            opacity: 1; 
            pointer-events: auto;
        }

        /* Cursor-tracking preview tooltips */
        .preview-tooltip {
            position: fixed;
            background: #0a0a0a;
            border: 1px solid #333;
            padding: 12px 14px;
            border-radius: 4px;
            pointer-events: none;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.2s;
            max-width: 280px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.6);
        }

        .preview-tooltip.show {
            opacity: 1;
        }

        .preview-tooltip-header {
            font-size: 0.75rem;
            font-weight: 600;
            color: #fff;
            margin-bottom: 6px;
        }

        .preview-tooltip-subtext {
            font-size: 0.6rem;
            color: #888;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .preview-tooltip-bio {
            font-size: 0.65rem;
            color: #aaa;
            line-height: 1.4;
            margin-bottom: 6px;
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
        }

        .preview-tooltip-episodes {
            font-size: 0.6rem;
            color: #666;
            margin-top: 6px;
            padding-top: 6px;
            border-top: 1px solid #222;
        }

        .preview-tooltip-label {
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        /* Timeline button tooltip */
        .timeline-btn-tooltip {
            position: fixed;
            background: #0a0a0a;
            border: 1px solid #333;
            padding: 8px 12px;
            border-radius: 4px;
            pointer-events: none;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.2s;
            box-shadow: 0 4px 12px rgba(0,0,0,0.6);
            font-size: 0.7rem;
            color: #fff;
            white-space: nowrap;
        }
        
        .timeline-btn-tooltip.show {
            opacity: 1;
        }

        /* Lore Node */
        .lore-node {
            position: absolute;
            left: 30px;
            top: 50%;
            transform: translateY(-50%);
            width: 100px;
            padding: 12px;
            background: var(--node-bg);
            border: 2px solid var(--border);
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
            z-index: 100;
            transition: left 0.3s ease;
        }
        
        .lore-node.hidden {
            left: -180px;
        }
        
        .lore-toggle {
            position: fixed;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 24px;
            height: 60px;
            background: var(--node-bg);
            border: 2px solid var(--border);
            border-left: none;
            border-radius: 0 8px 8px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 101;
            transition: none;
        }
        
        .lore-toggle:hover {
            background: rgba(255,255,255,0.05);
            border-color: #555;
        }
        
        .lore-toggle-arrow {
            width: 0;
            height: 0;
            border-top: 8px solid transparent;
            border-bottom: 8px solid transparent;
            border-right: 10px solid var(--text-dim);
            transition: transform 0.3s ease;
        }
        
        .lore-toggle.panel-hidden .lore-toggle-arrow {
            transform: rotate(180deg);
        }

        .lore-node-label {
            font-size: 0.6rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-dim);
            margin-bottom: 3px;
        }

        .lore-icon-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
            width: 100%;
        }

        .lore-icon {
            width: 100%;
            height: 55px;
            background: rgba(0,0,0,0.3);
            border: 1px solid var(--border);
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: 0.2s;
            gap: 3px;
        }

        .lore-icon:hover {
            background: rgba(255,255,255,0.05);
            border-color: #555;
        }

        .lore-icon-symbol {
            font-size: 1.4rem;
        }

        .lore-icon-label {
            font-size: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-dim);
        }

        /* Glossary Overlay */
        .glossary-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.95);
            z-index: 10000;
            display: none;
        }

        .glossary-overlay.active {
            display: block;
        }

        .glossary-iframe {
            width: 100%;
            height: 100%;
            border: none;
        }
        
        /* Statistics Overlay */
        .statistics-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.95);
            z-index: 10001;
            display: none;
        }

        .statistics-overlay.active {
            display: block;
        }

        .statistics-iframe {
            width: 100%;
            height: 100%;
            border: none;
        }

        /* Glossary term highlighting in text */
        .glossary-term-highlight {
            background: rgba(255, 255, 255, 0.08);
            padding: 2px 6px;
            border-radius: 12px;
            border: 1px solid;
            cursor: pointer;
            position: relative;
            transition: 0.2s;
            display: inline-block;
        }

        .glossary-term-highlight:hover {
            background: rgba(255, 255, 255, 0.12);
            filter: brightness(1.2);
        }
        
        .glossary-preview-tooltip {
            position: fixed;
            background: #0a0a0a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
            max-width: 280px;
            z-index: 10000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }
        
        .glossary-preview-tooltip.show {
            opacity: 1;
        }
        
        .glossary-preview-image {
            width: 100%;
            height: 120px;
            background: #000;
            border: 1px solid #222;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }
        
        .glossary-preview-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .glossary-preview-image-placeholder {
            color: #333;
            font-size: 0.6rem;
        }
        
        .glossary-preview-name {
            font-size: 0.85rem;
            font-weight: 500;
            margin-bottom: 5px;
        }
        
        .glossary-preview-type {
            font-size: 0.55rem;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 10px;
        }
        
        .glossary-preview-description {
            font-size: 0.65rem;
            color: #aaa;
            line-height: 1.4;
        }

        /* Character name highlighting in text */
        .char-name-highlight {
            border: 1px solid;
            padding: 1px 3px;
            border-radius: 3px;
            cursor: pointer;
            position: relative;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            transition: 0.2s;
        }

        .char-name-highlight:hover {
            filter: brightness(1.2);
            box-shadow: 0 3px 6px rgba(0,0,0,0.5);
        }

        .tm-btn { 
            background: var(--hud-bg);
            border: 1px solid var(--hud-border);
            color: var(--text-dim);
            font-size: 0.55rem; 
            padding: 4px 8px; 
            text-transform: uppercase; 
            cursor: pointer; 
            transition: 0.2s; 
            letter-spacing: 1px;
            height: 28px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            box-sizing: border-box;
        }
        .tm-btn:hover { 
            color: var(--hud-text);
            border-color: var(--text-dim);
        }
        
        /* Larger icons for timeline controls */
        .tm-btn[onclick*="toggleDistribution"],
        .tm-btn[onclick*="resetGraphView"] {
            font-size: 0.9rem;
            padding: 4px;
            width: 28px;
        }
        
        /* Modal buttons always dark regardless of theme */
        .modal-content .tm-btn,
        #lightbox .tm-btn {
            background: #0a0a0a;
            border-color: #222;
            color: #999;
        }
        
        .modal-content .tm-btn:hover,
        #lightbox .tm-btn:hover {
            color: #fff;
            border-color: #999;
        }
        
        .view-center-circle {
            width: 40px; 
            height: 40px; 
            border: 1px solid var(--pipe-color);
            border-radius: 50%; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            cursor: pointer;
            color: var(--text-dim);
            font-size: 1.1rem; 
            transition: 0.3s; 
            background: var(--node-bg);
            backdrop-filter: blur(5px); 
            margin-top: 10px;
        }
        .view-center-circle:hover { 
            border-color: var(--text-primary);
            color: var(--text-primary);
            transform: scale(1.1); 
        }

        /* --- CHARACTER JOURNAL MODAL --- */
        .character-modal-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 30px;
            padding: 40px;
            max-width: 90vw;
            max-height: 90vh;
            pointer-events: all;
        }

        .character-journal {
            width: 800px;
            max-height: 70vh;
            background: rgba(12, 12, 12, 0.95);
            border: 1px solid #333;
            border-radius: 15px;
            padding: 30px;
            overflow-y: auto;
        }

        .journal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            border-bottom: 1px solid #222;
            padding-bottom: 15px;
        }

        .journal-header h2 {
            font-size: 1rem;
            font-weight: 300;
            letter-spacing: 3px;
            margin: 0;
            text-transform: uppercase;
        }

        .close-journal {
            font-size: 2rem;
            color: #666;
            cursor: pointer;
            transition: 0.2s;
            line-height: 1;
        }

        .close-journal:hover {
            color: #fff;
        }

        .character-list {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            align-items: flex-start;
        }

        .character-profile {
            width: 100px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .character-profile:hover {
            transform: scale(1.05);
        }

        .character-avatar {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: #111;
            border: 2px solid #333;
            object-fit: cover;
            transition: 0.2s;
        }

        .character-profile:hover .character-avatar {
            border-color: #666;
        }

        .character-name {
            font-size: 0.7rem;
            color: #ddd;
            text-align: center;
            max-width: 100px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .add-character-btn {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: rgba(20, 20, 20, 0.8);
            border: 2px dashed #444;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            color: #444;
            cursor: pointer;
            transition: 0.3s;
        }

        .add-character-btn:hover {
            border-color: #fff;
            color: #fff;
            background: rgba(30, 30, 30, 0.9);
            transform: scale(1.05);
        }

        /* Character detail view */
        .character-detail-view {
            width: 500px;
            background: rgba(12, 12, 12, 0.98);
            border: 1px solid #333;
            border-radius: 15px;
            padding: 40px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 25px;
        }

        .detail-avatar {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: #111;
            border: 4px solid #333;
            background-size: cover;
            background-position: center;
        }

        .detail-name {
            font-size: 1.5rem;
            font-weight: 400;
            letter-spacing: 2px;
            text-align: center;
        }

        .detail-buttons {
            display: flex;
            flex-direction: column;
            gap: 12px;
            width: 100%;
        }

        .detail-btn {
            padding: 14px 24px;
            background: var(--node-bg);
            border: 1px solid var(--border);
            color: var(--text-primary);
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: 0.2s;
            border-radius: 8px;
            font-family: 'Inter', sans-serif;
        }

        .detail-btn:hover {
            background: var(--border);
        }

        .detail-btn.added {
            background: rgba(50, 100, 50, 0.3);
            color: #4a4;
            cursor: default;
            border-color: #4a4;
        }

        .detail-btn.remove {
            background: rgba(100, 30, 30, 0.3);
            border-color: var(--danger);
            color: var(--danger);
        }

        .detail-btn.remove:hover {
            background: rgba(100, 30, 30, 0.5);
        }

        .detail-btn.delete {
            background: rgba(100, 30, 30, 0.3);
            border-color: var(--danger);
            color: var(--danger);
        }

        .detail-btn.delete:hover {
            background: rgba(100, 30, 30, 0.5);
        }

        .detail-back {
            font-size: 0.7rem;
            color: #666;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: 0.2s;
        }

        .detail-back:hover {
            color: #fff;
        }

        /* --- CHARACTER PROFILE EDITOR --- */
        .character-editor-panel {
            width: 700px;
            max-height: 90vh;
            background: rgba(12, 12, 12, 0.98);
            border: 1px solid #333;
            border-radius: 15px;
            padding: 25px 30px;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.8);
        }

        .editor-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
            border-bottom: 1px solid #222;
            padding-bottom: 12px;
        }

        .editor-header h2 {
            font-size: 0.8rem;
            font-weight: 300;
            letter-spacing: 3px;
            margin: 0;
            flex-grow: 1;
        }

        .save-indicator {
            font-size: 0.5rem;
            color: #4a4;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .close-editor {
            font-size: 1.8rem;
            color: #666;
            cursor: pointer;
            transition: 0.2s;
            line-height: 1;
        }

        .close-editor:hover {
            color: #fff;
        }

        .editor-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px 20px;
        }

        .editor-section {
            display: flex;
            flex-direction: column;
        }

        .editor-section.full-width {
            grid-column: 1 / -1;
        }

        .editor-section label {
            font-size: 0.55rem;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 6px;
        }

        .editor-section input[type="text"],
        .editor-section textarea,
        .editor-section select {
            background: #000;
            border: 1px solid #333;
            color: #fff;
            padding: 8px 10px;
            font-family: 'Inter', sans-serif;
            font-size: 0.75rem;
            outline: none;
            border-radius: 4px;
            transition: 0.2s;
        }

        .editor-section input:focus,
        .editor-section textarea:focus,
        .editor-section select:focus {
            border-color: #666;
        }

        .editor-section textarea {
            min-height: 80px;
            resize: vertical;
        }

        .editor-section select {
            cursor: pointer;
        }

        .editor-row {
            display: flex;
            gap: 15px;
        }

        .char-preview-container {
            width: 100px;
            height: 100px;
            margin-bottom: 8px;
        }

        .char-preview-circle {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid #333;
            display: none;
        }

        .char-preview-circle.visible {
            display: block;
        }

        .char-placeholder-circle {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: #111;
            border: 2px dashed #333;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #444;
            font-size: 0.5rem;
        }

        .color-picker {
            width: 100%;
            height: 45px;
            border: 1px solid #333;
            background: #000;
            cursor: pointer;
            border-radius: 4px;
        }

        .color-preview {
            margin-top: 8px;
            height: 30px;
            border-radius: 4px;
            border: 1px solid #333;
        }

        /* --- CHARACTER JOURNAL MODAL --- */
        .character-modal-content {
            position: fixed;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            pointer-events: none;
        }

        /* Character Detail Popup - compact, horizontal layout */
        .character-detail-popup {
            position: absolute;
            top: 10vh;
            left: 50%;
            transform: translateX(-50%);
            width: 450px;
            min-height: fit-content;
            background: rgba(12, 12, 12, 0.98);
            border: 1px solid #333;
            border-radius: 15px;
            display: none;
            flex-direction: column;
            gap: 15px;
            padding: 20px 25px;
            pointer-events: all;
            box-shadow: 0 10px 50px rgba(0,0,0,0.8);
            opacity: 1;
            transition: opacity 1.5s ease-out;
        }

        .character-detail-popup.active {
            display: flex;
        }

        .character-detail-popup.fading {
            opacity: 0;
        }

        .detail-left {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-shrink: 0;
        }

        .detail-avatar {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: #111;
            border: 3px solid #333;
            background-size: cover;
            background-position: center;
            flex-shrink: 0;
        }

        .detail-name {
            font-size: 1rem;
            font-weight: 400;
            letter-spacing: 2px;
            text-align: left;
            flex: 1;
        }

        .detail-appears {
            font-size: 0.6rem;
            color: #666;
            margin-top: 6px;
            padding-top: 6px;
            border-top: 1px solid #222;
        }

        .detail-appears-label {
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .detail-buttons {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .detail-btn {
            width: 100%;
            padding: 10px 12px;
            background: var(--node-bg);
            border: 1px solid var(--border);
            color: var(--text-primary);
            font-size: 0.6rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: 0.2s;
            border-radius: 8px;
            font-family: 'Inter', sans-serif;
            font-weight: 600;
        }

        .detail-btn:hover:not(.added) {
            background: var(--border);
        }

        .detail-btn.added {
            background: rgba(50, 100, 50, 0.3);
            color: #4a4;
            cursor: default;
            border-color: #4a4;
        }

        .detail-btn.delete {
            background: rgba(100, 30, 30, 0.3);
            border-color: var(--danger);
            color: var(--danger);
        }

        .detail-btn.delete:hover {
            background: rgba(100, 30, 30, 0.5);
        }

        /* Character Journal - compact bottom panel */
        .character-journal {
            width: 900px;
            max-height: 45vh;
            background: rgba(12, 12, 12, 0.95);
            border: 1px solid #333;
            border-radius: 15px 15px 0 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-self: center;
            pointer-events: all;
            box-shadow: 0 -10px 50px rgba(0,0,0,0.8);
        }

        .journal-header {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 15px 30px;
            border-bottom: 1px solid #222;
            flex-shrink: 0;
        }

        .journal-header h2 {
            font-size: 0.9rem;
            font-weight: 300;
            letter-spacing: 3px;
            margin: 0;
            text-transform: uppercase;
        }

        /* Character List Section */
        .character-list-section {
            flex: 1;
            padding: 25px 30px 20px 30px;
            overflow-y: auto;
        }

        .character-list {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            align-items: flex-start;
        }

        .character-profile {
            width: 100px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            transition: transform 0.2s;
            position: relative;
        }

        .character-profile:hover {
            transform: scale(1.05);
        }

        .character-avatar {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: #111;
            border: 2px solid #333;
            object-fit: cover;
            transition: 0.2s;
            background-size: cover;
            background-position: center;
        }

        .character-profile:hover .character-avatar {
            border-color: #666;
        }

        .character-name {
            font-size: 0.7rem;
            color: #ddd;
            text-align: center;
            max-width: 100px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .add-character-btn {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: rgba(20, 20, 20, 0.8);
            border: 2px dashed #444;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            color: #444;
            cursor: pointer;
            transition: 0.3s;
        }

        .add-character-btn:hover {
            border-color: #fff;
            color: #fff;
            background: rgba(30, 30, 30, 0.9);
            transform: scale(1.05);
        }

        /* Dismiss button at bottom */
        .journal-footer {
            padding: 15px 30px;
            border-top: 1px solid #222;
            display: flex;
            justify-content: center;
        }

        .dismiss-journal-btn {
            padding: 12px 30px;
            background: var(--node-bg);
            border: 1px solid var(--border);
            color: var(--text-dim);
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: 0.2s;
            border-radius: 8px;
            font-family: 'Inter', sans-serif;
            font-weight: 600;
        }

        .dismiss-journal-btn:hover {
            background: var(--border);
            color: var(--text-primary);
        }

        /* Scene Characters in Node */
        .scene-characters-row {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 8px;
        }

        .scene-char-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #111;
            border: 2px solid #333;
            cursor: pointer;
            transition: 0.2s;
            background-size: cover;
            background-position: center;
        }

        .scene-char-avatar:hover {
            transform: scale(1.1);
            border-color: var(--danger);
        }

        /* --- CHARACTER INFO PANEL (View Only) --- */
        .character-info-panel {
            width: 500px;
            max-height: 80vh;
            background: rgba(12, 12, 12, 0.98);
            border: 1px solid #333;
            border-radius: 15px;
            padding: 30px;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.8);
        }

        .info-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            border-bottom: 1px solid #222;
            padding-bottom: 15px;
        }

        .info-header h2 {
            font-size: 1.2rem;
            font-weight: 400;
            letter-spacing: 2px;
            margin: 0;
        }

        .close-info {
            font-size: 2rem;
            color: #666;
            cursor: pointer;
            transition: 0.2s;
            line-height: 1;
        }

        .close-info:hover {
            color: #fff;
        }

        .info-content {
            display: flex;
            flex-direction: column;
            gap: 25px;
        }

        .info-avatar-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .info-avatar {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            background: #111;
            border: 3px solid #333;
            background-size: cover;
            background-position: center;
        }

        .info-color-badge {
            width: 60px;
            height: 30px;
            border-radius: 15px;
            border: 1px solid #333;
        }

        .info-details {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .info-row {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .info-row label {
            font-size: 0.6rem;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .info-value {
            font-size: 0.9rem;
            color: #ddd;
            line-height: 1.6;
        }

        .bio-text {
            white-space: pre-wrap;
            max-height: 200px;
            overflow-y: auto;
            padding: 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            border: 1px solid #222;
        }

        .info-notice {
            margin-top: 20px;
            padding: 15px;
            background: rgba(40, 40, 60, 0.3);
            border: 1px solid #334;
            border-radius: 6px;
            font-size: 0.75rem;
            color: #999;
            text-align: center;
            line-height: 1.5;
        }

        /* --- SETTINGS PANEL --- */
        .settings-panel {
            width: 400px;
            background: rgba(12, 12, 12, 0.98);
            border: 1px solid #333;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.8);
        }

        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            border-bottom: 1px solid #222;
            padding-bottom: 15px;
        }

        .settings-header h2 {
            font-size: 0.9rem;
            font-weight: 300;
            letter-spacing: 3px;
            margin: 0;
        }

        .close-settings {
            font-size: 2rem;
            color: #666;
            cursor: pointer;
            transition: 0.2s;
            line-height: 1;
        }

        .close-settings:hover {
            color: #fff;
        }

        .settings-content {
            display: flex;
            flex-direction: column;
            gap: 25px;
        }

        .setting-row {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .setting-label {
            font-size: 0.65rem;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .setting-input {
            background: #0a0a0a;
            border: 1px solid #333;
            color: #fff;
            padding: 10px 12px;
            font-family: 'Inter', sans-serif;
            font-size: 0.8rem;
            outline: none;
            border-radius: 4px;
            transition: 0.2s;
        }

        .setting-input:focus {
            border-color: #666;
        }

        .setting-hint {
            font-size: 0.6rem;
            color: #666;
            font-style: italic;
            line-height: 1.4;
        }
        
        .setting-btn {
            background: #222;
            border: 1px solid #444;
            color: #fff;
            padding: 10px 20px;
            font-family: 'Inter', sans-serif;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            border-radius: 4px;
            transition: 0.2s;
        }
        
        .setting-btn:hover {
            background: #333;
        }
        
        .danger-btn {
            background: #1a0505;
            border-color: #662222;
            color: #ff4444;
        }
        
        .danger-btn:hover {
            background: #2a0808;
            color: #ff6666;
        }

        .subunit-bracket {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .bracket-symbol {
            font-size: 3rem;
            color: #444;
            line-height: 1;
            font-weight: 100;
        }

        .subunit-inputs {
            display: flex;
            flex-direction: column;
            gap: 8px;
            flex: 1;
        }

        .subunit-input {
            margin-bottom: 0 !important;
        }

        .toggle-switch {
            position: relative;
            width: 180px;
            height: 40px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 15px;
            transition: 0.3s;
        }

        .toggle-slider {
            position: absolute;
            left: 4px;
            width: 80px;
            height: 32px;
            background: #fff;
            border-radius: 16px;
            transition: 0.3s;
        }

        .toggle-switch.active .toggle-slider {
            left: calc(100% - 84px);
        }

        .toggle-text-left,
        .toggle-text-right {
            font-size: 0.7rem;
            font-weight: 600;
            z-index: 1;
            transition: 0.3s;
        }

        .toggle-text-left {
            color: #1a1a1a;
        }

        .toggle-text-right {
            color: #666;
        }

        .toggle-switch.active .toggle-text-left {
            color: #666;
        }

        .toggle-switch.active .toggle-text-right {
            color: #1a1a1a;
        }

        /* 4-Way Theme Toggle */
        .theme-toggle-4way {
            position: relative;
            width: 100%;
            height: 80px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 12px;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            padding: 4px;
            gap: 4px;
        }

        .theme-slider {
            position: absolute;
            width: calc(25% - 5px);
            height: calc(100% - 8px);
            background: #fff;
            border-radius: 8px;
            transition: 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            left: 4px;
            top: 4px;
            z-index: 0;
        }

        .theme-option {
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 1;
            transition: 0.2s;
            border-radius: 8px;
        }

        .theme-option span {
            font-size: 0.65rem;
            font-weight: 600;
            text-align: center;
            line-height: 1.3;
            color: #666;
            transition: 0.2s;
        }

        .theme-option.active span {
            color: #1a1a1a;
        }

        .theme-toggle-4way[data-active="dark"] .theme-slider {
            left: 4px;
        }

        .theme-toggle-4way[data-active="light-on-dark"] .theme-slider {
            left: calc(25% + 1px);
        }

        .theme-toggle-4way[data-active="dark-on-light"] .theme-slider {
            left: calc(50% - 2px);
        }

        .theme-toggle-4way[data-active="light"] .theme-slider {
            left: calc(75% - 5px);
        }
        
                /* Atlas Overlay */
        .atlas-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(3px);
            display: none;
            z-index: 10002;
        }
        
        .atlas-overlay.active {
            display: block;
        }
        
        .atlas-iframe {
            width: 100%;
            height: 100%;
            border: none;
        }
        
/* Flash animation for empty state */
        @keyframes flash {
            0%, 100% { 
                box-shadow: 0 0 0 rgba(255, 255, 255, 0);
            }
            50% { 
                box-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
            }
        }
    </style>
</head>
<body>

    <header class="workspace-header">
        <div class="brand-block">
            <div class="back-btn" onclick="exitWorkspace()"></div>
            <div class="nav-text">
                <strong>CHRONOVIST</strong> <span class="title-sep">|</span> CREATION PLANE 
                <span style="color: #444; margin: 0 10px;">//</span> 
                <span id="project-name-display" style="color: #fff; opacity: 0.8;"></span>
            </div>
        </div>
        <div class="status-block">
            <div id="save-status" class="save-indicator">CHANGES SYNCED</div>
            <div id="workspace-clock" class="clock-block"></div>
        </div>
    </header>

    <div id="year-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-title">Episode Number</div>
            <input type="number" id="year-input" class="modal-input" placeholder="#">
            <div id="year-error" style="color: #ff4444; font-size: 0.75rem; min-height: 20px; opacity: 0; transition: opacity 0.3s;"></div>
            <div style="display: flex; gap: 10px; justify-content: center;">
                <button class="tm-btn" onclick="closeYearModal()">Cancel</button>
                <button class="tm-btn" style="color:#fff; border-color:#fff;" onclick="confirmNewYear()">Create</button>
            </div>
        </div>
    </div>
    
    <!-- Episode Banner Modal -->
    <div id="banner-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <div class="modal-title">Episode Banner</div>
            <input type="text" id="banner-url-input" class="modal-input" placeholder="Image URL or upload below">
            <div style="margin: 15px 0; text-align: center; color: var(--text-dim); font-size: 0.75rem;">OR</div>
            <input type="file" id="banner-file-input" accept="image/*" style="display: none;" onchange="handleBannerUpload(this)">
            <button class="tm-btn" onclick="document.getElementById('banner-file-input').click()" style="width: 100%; margin-bottom: 10px;">Upload Image</button>
            <div style="display: flex; gap: 10px; justify-content: center; margin-top: 10px;">
                <button class="tm-btn" style="color: #ff4444; border-color: #ff4444;" onclick="clearBanner()">Clear Image</button>
                <button class="tm-btn" onclick="closeBannerModal()">Cancel</button>
                <button class="tm-btn" style="color:#fff; border-color:#fff;" onclick="confirmBanner()">Set Banner</button>
            </div>
        </div>
    </div>
    
    <!-- Event Image Upload Modal -->
    <div id="event-image-modal" class="modal-overlay" style="display: none; z-index: 4000;" onclick="closeEventImageModal()">
        <div class="modal-content" style="width: 400px;" onclick="event.stopPropagation();">
            <div class="modal-title">Add Event Image</div>
            <div style="margin-bottom: 20px;">
                <label style="display: block; font-size: 0.6rem; color: #888; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px;">Image URL</label>
                <input type="text" id="event-image-url" class="modal-input" placeholder="Paste image URL here..." style="text-align: left; font-size: 0.85rem;">
            </div>
            <div style="margin: 20px 0; text-align: center; color: var(--text-dim); font-size: 0.75rem; text-transform: uppercase; letter-spacing: 1px;">OR</div>
            <input type="file" id="event-image-file" accept="image/*" style="display: none;" onchange="handleEventImageUpload(this)">
            <button class="tm-btn" onclick="document.getElementById('event-image-file').click()" style="width: 100%; margin-bottom: 20px; padding: 12px; font-size: 0.75rem;">Upload from Device</button>
            <div style="display: flex; gap: 10px; justify-content: center; margin-top: 10px;">
                <button class="tm-btn" onclick="closeEventImageModal()" style="flex: 1;">Cancel</button>
                <button class="tm-btn" style="color:#4a4; border-color:#4a4; flex: 1;" onclick="confirmEventImage()">Confirm</button>
            </div>
        </div>
    </div>

    <div id="lightbox" class="modal-overlay" onclick="closeLightbox(event)">
        <div id="lightbox-img-container" onclick="event.stopPropagation()">
            <img id="lightbox-img" src="" alt="Event Media">
            <div class="lightbox-controls">
                <button class="tm-btn" style="color:var(--danger)" onclick="deleteLightboxImage()">Delete</button>
                <button class="tm-btn" onclick="replaceLightboxImage()">Replace</button>
                <button class="tm-btn" onclick="document.getElementById('lightbox').style.display='none'">Close</button>
            </div>
        </div>
    </div>

    <div id="character-overlay" class="modal-overlay" style="display:none;">
        <div class="character-modal-content" onclick="event.stopPropagation()">
            <!-- Character Detail Popup - compact horizontal layout -->
            <div id="character-detail-popup" class="character-detail-popup">
                <div class="detail-left">
                    <div id="detail-avatar" class="detail-avatar"></div>
                    <div style="flex: 1;">
                        <div id="detail-name" class="detail-name"></div>
                        <div id="detail-appears" class="detail-appears">
                            <span class="detail-appears-label">Appears in Episode(s):</span>
                            <span id="detail-appears-list">None</span>
                        </div>
                    </div>
                </div>
                <div class="detail-buttons">
                    <button id="add-to-episode-btn" class="detail-btn" onclick="addCharacterFromDetail()">Add Character to Episode</button>
                    <button class="detail-btn" onclick="editCharacterFromDetail()">Edit Character</button>
                    <button class="detail-btn delete" onclick="deleteCharacterFromDetail()">Delete Character</button>
                </div>
            </div>

            <!-- Character Journal - bottom panel -->
            <div id="character-journal" class="character-journal">
                <div class="journal-header">
                    <h2>CHARACTER JOURNAL</h2>
                </div>

                <div class="character-list-section">
                    <div class="character-list" id="character-list">
                        <!-- Character profiles will be rendered here -->
                    </div>
                </div>

                <div class="journal-footer">
                    <button class="dismiss-journal-btn" onclick="closeCharacterJournal()">Dismiss Character Journal</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Character Profile Editor -->
    <div id="character-editor-overlay" class="modal-overlay" style="display:none; z-index:4000;">
        <div class="character-editor-panel" onclick="event.stopPropagation()">
            <div class="editor-header">
                <h2 id="editor-title">NEW CHARACTER</h2>
                <div class="save-indicator">Auto-saved</div>
                <div class="close-editor" onclick="closeCharacterEditor()"></div>
            </div>

            <div class="editor-content">
                <div class="editor-section">
                    <label>Character Name</label>
                    <input type="text" id="char-name" placeholder="Enter name..." oninput="autoSaveCharacter()">
                </div>

                <div class="editor-section">
                    <label>Status</label>
                    <select id="char-status" onchange="autoSaveCharacter()">
                        <option value="Unknown">Unknown</option>
                        <option value="Alive">Alive</option>
                        <option value="Deceased">Deceased</option>
                        <option value="Missing">Missing</option>
                        <option value="Imprisoned">Imprisoned</option>
                    </select>
                </div>

                <div class="editor-section full-width">
                    <label>Aliases (comma-separated)</label>
                    <input type="text" id="char-aliases" placeholder="e.g. The Shadow, Johnny" oninput="autoSaveCharacter()">
                </div>

                <div class="editor-section">
                    <label>Photo Reference</label>
                    <div class="char-preview-container">
                        <div id="char-placeholder" class="char-placeholder-circle">Empty</div>
                        <img src="" id="char-preview-img" class="char-preview-circle">
                    </div>
                    <button class="tm-btn" onclick="document.getElementById('char-img-upload').click()" style="margin-top:8px; font-size:0.65rem; padding:6px 12px;">Upload</button>
                    <input type="text" id="char-img-url" placeholder="Or URL" oninput="autoSaveCharacter()" style="margin-top:6px;">
                </div>

                <div class="editor-section">
                    <label>Color Code</label>
                    <input type="color" id="char-color" value="#888888" oninput="autoSaveCharacter()" class="color-picker">
                    <div class="color-preview" id="color-preview"></div>
                </div>

                <div class="editor-section full-width">
                    <label>Biography</label>
                    <textarea id="char-bio" placeholder="Character background and details..." oninput="autoSaveCharacter()"></textarea>
                </div>

                <div class="editor-section full-width" id="char-appearances-section" style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #222;">
                    <label>Appears in <span id="char-appears-unit">${timelineUnit}</span>(s):</label>
                    <div id="char-appears-list" style="font-size: 0.75rem; color: #888; margin-top: 6px;">
                        None
                    </div>
                </div>
            </div>
        </div>
    </div>

    <input type="file" id="char-img-upload" hidden accept="image/*" onchange="handleCharacterImageUpload(this)">

    <!-- Character Info Panel (View Only) -->
    <div id="character-info-overlay" class="modal-overlay" style="display:none; z-index:4500;" onclick="closeCharacterInfo()">
        <div class="character-info-panel" onclick="event.stopPropagation()">
            <div class="info-header">
                <h2 id="info-char-name">Character Name</h2>
                <div class="close-info" onclick="closeCharacterInfo()"></div>
            </div>

            <div class="info-content">
                <div class="info-avatar-section">
                    <div id="info-avatar" class="info-avatar"></div>
                    <div id="info-color-badge" class="info-color-badge"></div>
                </div>

                <div class="info-details">
                    <div class="info-row" id="info-aliases-row" style="display:none;">
                        <label>Aliases</label>
                        <div id="info-aliases" class="info-value"></div>
                    </div>

                    <div class="info-row">
                        <label>Status</label>
                        <div id="info-status" class="info-value"></div>
                    </div>

                    <div class="info-row" id="info-bio-row" style="display:none;">
                        <label>Biography</label>
                        <div id="info-bio" class="info-value bio-text"></div>
                    </div>

                    <div class="info-notice">
                        Select the Characters node to edit Character Profiles.
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="trash-zone" title="Drop Plot here to delete"></div>
    
    <!-- Empty State Message -->
    <div id="plane-container">
        <div id="landing-message">Select an existing Episode on the timeline or create a new Episode</div>
        <div id="node-group">
            <div class="grid-node" id="episode-node" onclick="handleEpisodeNodeClick(event)">
                <div class="grid-node-content">
                    <div class="node-label">Episode</div>
                    <h2 id="grid-year-display">0000</h2>
                    <input type="text" id="episode-title" class="episode-title-input" placeholder="Episode Title" oninput="handleEpisodeTitle(this)" onclick="event.stopPropagation()">
                </div>
            </div>
            <div class="node-pipe"></div>
            
            <div class="sub-node" onclick="openCharacterJournal()">
                <div class="node-label">Characters</div>
                <div style="font-size: 0.5rem; color: #444;">Click here to add characters/view Character Journal</div>
            </div>
            <div class="node-pipe"></div>

            <div class="synopsis-node">
                <div class="node-label" style="margin-bottom:8px;">Synopsis</div>
                <div id="synopsis-text" 
                     class="synopsis-input" 
                     contenteditable="true" 
                     placeholder="Enter year synopsis..." 
                     oninput="handleSynopsis(this)"
                     onblur="processCharacterNamesInSynopsis()"></div>
            </div>
            
            <div id="grid-toggle-container" style="display: flex; justify-content: center; margin: 20px 0; opacity: 0; transition: opacity 0.3s;" onmouseenter="this.style.opacity='1'" onmouseleave="this.style.opacity='0'">
                <div id="grid-toggle-eye" onclick="toggleEmptyGridCells()" style="font-size: 3rem; cursor: pointer; color: var(--text-dim); transition: color 0.2s;" title="Clean view (hide empty slots)"></div>
            </div>

            <div id="plot-grid" class="plot-grid"></div>
        </div>
        
        <!-- Plot Swap/Bump Modal -->
        <div id="plot-placement-modal" class="modal-overlay" style="display: none;">
            <div class="modal-panel" style="width: 400px;">
                <div class="modal-header">Space Occupied</div>
                <div class="modal-body" style="padding: 20px; text-align: center;">
                    <p style="margin-bottom: 20px;">This grid space already contains a plot. What would you like to do?</p>
                    <div style="display: flex; gap: 10px; justify-content: center;">
                        <button class="setting-btn" onclick="swapPlots()" style="flex: 1;">Swap Plots</button>
                        <button class="setting-btn" onclick="bumpPlots()" style="flex: 1;">Bump Down</button>
                        <button class="setting-btn" onclick="cancelPlotPlacement()" style="flex: 1;">Cancel</button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Plot Deletion Confirmation Modal -->
        <div id="plot-delete-modal" class="modal-overlay" style="display: none;">
            <div class="modal-panel" style="width: 400px;">
                <div class="modal-header">Delete Plot?</div>
                <div class="modal-body" style="padding: 20px; text-align: center;">
                    <p style="margin-bottom: 20px;">Are you sure you want to delete this plot and all its events?</p>
                    <div style="display: flex; gap: 10px; justify-content: center;">
                        <button class="setting-btn danger-btn" onclick="confirmDeletePlot()" style="flex: 1;">Delete</button>
                        <button class="setting-btn" onclick="cancelDeletePlot()" style="flex: 1;">Cancel</button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Arrow Management Modal -->
        <div id="arrow-management-modal" class="modal-overlay" style="display: none;">
            <div class="modal-panel" style="width: 500px; max-height: 600px;">
                <div class="modal-header">Manage Connections</div>
                <div class="modal-body" style="padding: 20px;">
                    <p id="arrow-modal-description" style="margin-bottom: 15px; color: var(--text-dim);"></p>
                    <div id="arrow-list-container" style="max-height: 300px; overflow-y: auto; border: 1px solid var(--hud-border); border-radius: 6px; padding: 10px; background: rgba(0,0,0,0.3);">
                        <!-- Arrow items will be populated here -->
                    </div>
                    <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
                        <button class="setting-btn danger-btn" onclick="deleteSelectedArrows()" id="delete-arrows-btn" style="flex: 0;">Delete Selected</button>
                        <button class="setting-btn" onclick="cancelArrowManagement()" style="flex: 0;">Close</button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Event Deletion Confirmation Modal -->
        <div id="event-delete-modal" class="modal-overlay" style="display: none; z-index: 4000;" onclick="cancelDeleteEvent()">
            <div class="modal-content" style="width: 400px;" onclick="event.stopPropagation();">
                <div class="modal-title">Delete Event?</div>
                <p style="margin: 20px 0; text-align: center; color: var(--text-dim);">Are you sure you want to delete this event? This action cannot be undone.</p>
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button class="tm-btn" onclick="cancelDeleteEvent()" style="flex: 1;">Cancel</button>
                    <button class="tm-btn" style="color:#d44; border-color:#d44; flex: 1;" onclick="confirmDeleteEvent()">Delete</button>
                </div>
            </div>
        </div>
        
        <!-- Arrow Management Modal -->
        <div id="arrow-management-modal" class="modal-overlay" style="display: none;">
            <div class="modal-panel" style="width: 500px; max-height: 600px;">
                <div class="modal-header">Manage Arrows</div>
                <div class="modal-body" style="padding: 20px;">
                    <div id="arrow-list" style="max-height: 400px; overflow-y: auto; margin-bottom: 20px;"></div>
                    <div style="display: flex; gap: 10px; justify-content: flex-end;">
                        <button class="setting-btn danger-btn" onclick="deleteSelectedArrows()" style="flex: 1;">Delete Selected</button>
                        <button class="setting-btn" onclick="closeArrowManagement()" style="flex: 1;">Close</button>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="timeline-hud">
            <div id="timeline-bar"></div>
            <div style="display: flex; gap: 10px;">
                <button class="tm-btn timeline-btn" data-tooltip="Settings" onclick="openSettingsModal()" style="font-size: 0.9rem; padding: 4px; width: 28px;"></button>
                <button class="tm-btn timeline-btn" data-tooltip="Toggle Distribution" onclick="toggleDistribution()"></button>
                <button id="center-btn" class="tm-btn timeline-btn" data-tooltip="Reset View" style="display:none;" onclick="resetGraphView()"></button>
                <button class="tm-btn timeline-btn" data-tooltip="Create a new Timeline tick" onclick="openYearModal()">[+ Episode]</button>
            </div>
        </div>
        
        <div id="timeline-toggle" onclick="toggleTimelineHud()">
            <div class="timeline-toggle-arrow"></div>
        </div>
    </div>

    <!-- Settings Panel -->
    <div id="settings-overlay" class="modal-overlay" style="display:none; z-index:3500;">
        <div class="settings-panel" onclick="event.stopPropagation()">
            <div class="settings-header">
                <h2>SETTINGS</h2>
                <div class="close-settings" onclick="closeSettingsModal()"></div>
            </div>
            
            <div class="settings-content">
                <div class="setting-row">
                    <label class="setting-label">Timeline Unit</label>
                    <input type="text" id="timeline-unit-input" class="setting-input" placeholder="Episode" value="Episode" maxlength="25" oninput="updateTimelineUnit(this.value)">
                    <div class="setting-hint">Define the terminology for your timeline units (e.g., "Year", "Project", "Chapter")</div>
                </div>

                <div class="setting-row">
                    <label class="setting-label">Timeline Subunits</label>
                    <div class="subunit-bracket">
                        <div class="bracket-symbol">{</div>
                        <div class="subunit-inputs">
                            <input type="text" id="subunit-plot-input" class="setting-input subunit-input" placeholder="Scene" value="Scene" maxlength="20" oninput="updateSubunits()">
                            <input type="text" id="subunit-event-input" class="setting-input subunit-input" placeholder="Event" value="Event" maxlength="20" oninput="updateSubunits()">
                        </div>
                    </div>
                    <div class="setting-hint">Define terminology for plot structures and individual events</div>
                </div>

                <div class="setting-row">
                    <label class="setting-label">Theme Mode</label>
                    <div class="theme-toggle-4way">
                        <div id="theme-slider-4way" class="theme-slider"></div>
                        <div class="theme-option" data-theme="dark" onclick="setThemeMode('dark')">
                            <span>Dark</span>
                        </div>
                        <div class="theme-option" data-theme="light-on-dark" onclick="setThemeMode('light-on-dark')">
                            <span>Light<br>on Dark</span>
                        </div>
                        <div class="theme-option" data-theme="dark-on-light" onclick="setThemeMode('dark-on-light')">
                            <span>Dark<br>on Light</span>
                        </div>
                        <div class="theme-option" data-theme="light" onclick="setThemeMode('light')">
                            <span>Light</span>
                        </div>
                    </div>
                </div>
                
                <div class="setting-row" id="delete-episode-setting" style="display: none;">
                    <button class="setting-btn danger-btn" onclick="handleDeleteYear()">Delete <span class="timeline-unit-text">Episode</span></button>
                    <div class="setting-hint">Permanently delete the currently selected episode and all its data</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Cursor-tracking preview tooltips -->
    <div id="character-preview-tooltip" class="preview-tooltip"></div>
    <div id="episode-preview-tooltip" class="preview-tooltip"></div>
    <div id="glossary-preview-tooltip" class="glossary-preview-tooltip"></div>
    <div id="timeline-btn-tooltip" class="timeline-btn-tooltip"></div>

    <!-- Lore Node -->
    <div class="lore-node" id="lore-node">
        <div class="lore-node-label">Lore</div>
        <div class="lore-icon-container">
            <div class="lore-icon" onclick="openGlossary()">
                <div class="lore-icon-symbol"></div>
                <div class="lore-icon-label">Glossary</div>
            </div>
            <div class="lore-icon" onclick="openAtlas()">
                <div class="lore-icon-symbol"></div>
                <div class="lore-icon-label">Atlas</div>
            </div>
            <div class="lore-icon" onclick="openStatistics()">
                <div class="lore-icon-symbol"></div>
                <div class="lore-icon-label">Statistics</div>
            </div>
        </div>
    </div>
    
    <div class="lore-toggle" id="lore-toggle" onclick="toggleLorePanel()">
        <div class="lore-toggle-arrow"></div>
    </div>

    <!-- Glossary Overlay -->
    <div id="glossary-overlay" class="glossary-overlay">
        <iframe id="glossary-iframe" class="glossary-iframe"></iframe>
    </div>
    
    <!-- Statistics Overlay -->
    <div id="statistics-overlay" class="statistics-overlay">
        <iframe id="statistics-iframe" class="statistics-iframe"></iframe>
    </div>
    
    <!-- Atlas Overlay -->
    <div id="atlas-overlay" class="atlas-overlay">
        <iframe id="atlas-iframe" class="atlas-iframe"></iframe>
    </div>

    <script>
        // IndexedDB for image storage (supports much larger files)
        let imageDB = null;
        const DB_NAME = 'alphaline_images';
        const DB_VERSION = 1;
        const IMAGE_STORE = 'images';

        // Initialize IndexedDB
        function initImageDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                
                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    imageDB = request.result;
                    resolve(imageDB);
                };
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(IMAGE_STORE)) {
                        db.createObjectStore(IMAGE_STORE);
                    }
                };
            });
        }

        // Store image in IndexedDB
        async function storeImage(key, blob) {
            if (!imageDB) await initImageDB();
            
            return new Promise((resolve, reject) => {
                const transaction = imageDB.transaction([IMAGE_STORE], 'readwrite');
                const store = transaction.objectStore(IMAGE_STORE);
                const request = store.put(blob, key);
                
                request.onsuccess = () => resolve(key);
                request.onerror = () => reject(request.error);
            });
        }

        // Retrieve image from IndexedDB
        async function getImage(key) {
            if (!imageDB) await initImageDB();
            
            return new Promise((resolve, reject) => {
                const transaction = imageDB.transaction([IMAGE_STORE], 'readonly');
                const store = transaction.objectStore(IMAGE_STORE);
                const request = store.get(key);
                
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        // Delete image from IndexedDB
        async function deleteImage(key) {
            if (!imageDB) await initImageDB();
            
            return new Promise((resolve, reject) => {
                const transaction = imageDB.transaction([IMAGE_STORE], 'readwrite');
                const store = transaction.objectStore(IMAGE_STORE);
                const request = store.delete(key);
                
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        let plotsByYear = {}; 
        let selectedYear = null;
        let isDistributed = false;
        let panX = 0, panY = 0, gridZoom = 1;
        let timelineUnit = "Episode"; // Default timeline unit terminology
        let subunitPlot = "Scene"; // Default plot terminology
        let subunitEvent = "Event"; // Default event terminology

        // Characters data
        let characters = [];
        let editingCharacterId = null;

        // Lightbox State
        let lbContext = { pIdx: null, eIdx: null, col: null };

        // Drag State
        let dragSrcEl = null;
        let dragType = null; 
        
        // Grid placement state
        let pendingPlotPlacement = null; // {plotIndex, targetRow, targetCol, sourceRow, sourceCol}
        let pendingPlotDeletion = null; // plotIndex to delete
        let pendingEventDeletion = null; // {plotIndex, eventIndex}
        
        // Arrow connection state
        let draggingConnector = false;
        let connectorSource = null; // {plotIndex, row, col}
        let pendingArrowDeletion = null;
        let dragPreviewLine = null;
        
        // Initialize grid structure for current year
        function ensureGridStructure() {
            if (!plotsByYear[selectedYear]) {
                plotsByYear[selectedYear] = {
                    synopsis: '',
                    episodeTitle: '',
                    plots: [], // Array of {row, col, title, events: []}
                    arrows: [], // Array of {fromPlotIndex, toPlotIndex}
                    sceneCharacters: []
                };
            }
            if (!plotsByYear[selectedYear].plots) {
                // Migrate old column-based data if exists
                plotsByYear[selectedYear].plots = [];
                if (plotsByYear[selectedYear].left || plotsByYear[selectedYear].main || plotsByYear[selectedYear].right) {
                    // Convert old structure
                    const oldData = plotsByYear[selectedYear];
                    let plotArray = [];
                    if (oldData.left) oldData.left.forEach((p, i) => plotArray.push({...p, row: i, col: 0}));
                    if (oldData.main) oldData.main.forEach((p, i) => plotArray.push({...p, row: i, col: 1}));
                    if (oldData.right) oldData.right.forEach((p, i) => plotArray.push({...p, row: i, col: 2}));
                    plotsByYear[selectedYear].plots = plotArray;
                    delete oldData.left;
                    delete oldData.main;
                    delete oldData.right;
                }
            }
            if (!plotsByYear[selectedYear].arrows) {
                plotsByYear[selectedYear].arrows = [];
            }
        } 
        
        // Add plot to grid at specific position
        function addPlotToGrid(row, col) {
            if (!selectedYear) return;
            ensureGridStructure();
            
            const data = plotsByYear[selectedYear];
            data.plots.push({
                row: row,
                col: col,
                title: 'Add Text',
                events: []
            });
            
            renderPlotGrid();
            saveData();
        }
        
        // Plot drag handlers
        function handlePlotDragStart(event, plotIndex) {
            // Don't drag if clicking on event nodes or interactive elements
            if (event.target.closest('.event-node') || 
                event.target.closest('.event-input') ||
                event.target.closest('.event-image-container') ||
                event.target.closest('.event-tools') ||
                event.target.closest('.event-reorder') ||
                event.target.closest('.plot-title-field') ||
                event.target.closest('.tm-btn')) {
                event.preventDefault();
                return;
            }
            
            const wrapper = event.target.closest('.plot-node-wrapper');
            
            // Check if plot is locked
            if (wrapper.classList.contains('locked')) {
                event.preventDefault();
                return;
            }
            
            dragSrcEl = wrapper;
            dragType = 'plot';
            dragSrcEl.classList.add('dragging');
            document.body.classList.add('global-dragging');
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('plotIndex', plotIndex);
        }
        
        function togglePlotLock(plotIndex) {
            const data = plotsByYear[selectedYear];
            const plot = data.plots[plotIndex];
            
            // Toggle lock state
            plot.locked = !plot.locked;
            
            // Update UI
            const wrapper = document.querySelector(`.plot-node-wrapper[data-plot-idx="${plotIndex}"]`);
            const lockIcon = wrapper.querySelector('.plot-lock-icon');
            
            if (plot.locked) {
                wrapper.classList.add('locked');
                wrapper.setAttribute('draggable', 'false');
                lockIcon.textContent = '';
                lockIcon.title = 'Unlock plot';
            } else {
                wrapper.classList.remove('locked');
                wrapper.setAttribute('draggable', 'true');
                lockIcon.textContent = '';
                lockIcon.title = 'Lock plot';
            }
            
            saveData();
        }
        
        function handlePlotDragEnd(event) {
            if (dragSrcEl) {
                dragSrcEl.classList.remove('dragging');
            }
            document.body.classList.remove('global-dragging');
            document.querySelectorAll('.grid-cell').forEach(cell => {
                cell.classList.remove('drag-over');
            });
        }
        
        function handleGridDragOver(event) {
            if (dragType === 'plot') {
                event.preventDefault();
                event.dataTransfer.dropEffect = 'move';
                event.currentTarget.classList.add('drag-over');
            }
        }
        
        function handleGridDragLeave(event) {
            event.currentTarget.classList.remove('drag-over');
        }
        
        function handleGridDrop(event, targetRow, targetCol) {
            if (dragType !== 'plot') return;
            
            event.preventDefault();
            event.currentTarget.classList.remove('drag-over');
            
            const plotIndex = parseInt(event.dataTransfer.getData('plotIndex'));
            const data = plotsByYear[selectedYear];
            const plot = data.plots[plotIndex];
            
            if (!plot) return;
            
            const sourceRow = plot.row;
            const sourceCol = plot.col;
            
            // Check if target cell is occupied
            const existingPlot = data.plots.find(p => p.row === targetRow && p.col === targetCol);
            
            if (existingPlot && existingPlot !== plot) {
                // Show swap/bump modal
                pendingPlotPlacement = {
                    plotIndex: plotIndex,
                    targetRow: targetRow,
                    targetCol: targetCol,
                    sourceRow: sourceRow,
                    sourceCol: sourceCol
                };
                document.getElementById('plot-placement-modal').style.display = 'flex';
            } else {
                // Check if plot actually moved
                if (sourceRow !== targetRow || sourceCol !== targetCol) {
                    // Only remove arrows if position changed
                    removeArrowsForPlot(plotIndex);
                }
                
                plot.row = targetRow;
                plot.col = targetCol;
                renderPlotGrid();
                saveData();
            }
        }
        
        function swapPlots() {
            if (!pendingPlotPlacement) return;
            
            const data = plotsByYear[selectedYear];
            const movingPlot = data.plots[pendingPlotPlacement.plotIndex];
            const targetPlot = data.plots.find(p => p.row === pendingPlotPlacement.targetRow && p.col === pendingPlotPlacement.targetCol);
            
            if (movingPlot && targetPlot) {
                const targetPlotIndex = data.plots.indexOf(targetPlot);
                
                // Remove arrows for both plots
                removeArrowsForPlot(pendingPlotPlacement.plotIndex);
                removeArrowsForPlot(targetPlotIndex);
                
                // Swap positions
                const tempRow = movingPlot.row;
                const tempCol = movingPlot.col;
                movingPlot.row = targetPlot.row;
                movingPlot.col = targetPlot.col;
                targetPlot.row = tempRow;
                targetPlot.col = tempCol;
                
                renderPlotGrid();
                saveData();
            }
            
            cancelPlotPlacement();
        }
        
        function bumpPlots() {
            if (!pendingPlotPlacement) return;
            
            const data = plotsByYear[selectedYear];
            const movingPlot = data.plots[pendingPlotPlacement.plotIndex];
            const targetRow = pendingPlotPlacement.targetRow;
            const targetCol = pendingPlotPlacement.targetCol;
            
            // Get all plots in the target column at or below target row
            const plotsToMove = data.plots.filter(p => p.col === targetCol && p.row >= targetRow);
            
            // Remove arrows for all affected plots
            removeArrowsForPlot(pendingPlotPlacement.plotIndex);
            plotsToMove.forEach(p => {
                const idx = data.plots.indexOf(p);
                removeArrowsForPlot(idx);
            });
            
            // Move them all down one row
            plotsToMove.forEach(p => p.row += 1);
            
            // Move the dragged plot to the target position
            movingPlot.row = targetRow;
            movingPlot.col = targetCol;
            
            renderPlotGrid();
            saveData();
            cancelPlotPlacement();
        }
        
        function cancelPlotPlacement() {
            pendingPlotPlacement = null;
            document.getElementById('plot-placement-modal').style.display = 'none';
            renderPlotGrid();
        }
        
        // Update functions to work with grid indices
        function addEventToPlot(plotIndex) {
            const data = plotsByYear[selectedYear];
            data.plots[plotIndex].events.push({ 
                text: '', 
                img: null, 
                flipped: false,
                textWidth: 562,
                imageWidth: 460
            });
            renderPlotGrid();
            saveData();
        }
        
        function updatePlotTitle(plotIndex, value) {
            plotsByYear[selectedYear].plots[plotIndex].title = value;
            saveData();
        }
        
        function toggleEventSide(plotIndex, eventIndex) {
            const ev = plotsByYear[selectedYear].plots[plotIndex].events[eventIndex];
            ev.flipped = !ev.flipped;
            renderPlotGrid();
            saveData();
        }
        
        function deleteEvent(plotIndex, eventIndex) {
            pendingEventDeletion = {plotIndex, eventIndex};
            document.getElementById('event-delete-modal').style.display = 'flex';
        }
        
        function confirmDeleteEvent() {
            if (pendingEventDeletion) {
                plotsByYear[selectedYear].plots[pendingEventDeletion.plotIndex].events.splice(pendingEventDeletion.eventIndex, 1);
                renderPlotGrid();
                saveData();
            }
            cancelDeleteEvent();
        }
        
        function cancelDeleteEvent() {
            pendingEventDeletion = null;
            document.getElementById('event-delete-modal').style.display = 'none';
        }
        
        // Arrow management
        let selectedArrows = new Set();
        
        function openArrowManagement(plotIndex, connectorType) {
            event.stopPropagation();
            
            // Don't open if we just started dragging
            if (draggingConnector) return;
            
            const data = plotsByYear[selectedYear];
            if (!data || !data.arrows) return;
            
            const plot = data.plots[plotIndex];
            if (!plot) return;
            
            // Find relevant arrows
            let relevantArrows = [];
            if (connectorType === 'bottom') {
                // Outbound arrows (from this plot)
                relevantArrows = data.arrows.map((arrow, idx) => ({...arrow, index: idx}))
                    .filter(arrow => arrow.fromPlotIndex === plotIndex);
            } else {
                // Inbound arrows (to this plot)
                relevantArrows = data.arrows.map((arrow, idx) => ({...arrow, index: idx}))
                    .filter(arrow => arrow.toPlotIndex === plotIndex);
            }
            
            if (relevantArrows.length === 0) {
                return; // No arrows to manage
            }
            
            // Clear selection
            selectedArrows.clear();
            
            // Populate list
            const listContainer = document.getElementById('arrow-list');
            listContainer.innerHTML = '';
            
            relevantArrows.forEach(arrow => {
                const fromPlot = data.plots[arrow.fromPlotIndex];
                const toPlot = data.plots[arrow.toPlotIndex];
                
                if (!fromPlot || !toPlot) return;
                
                const item = document.createElement('div');
                item.style.cssText = 'padding: 12px; margin-bottom: 8px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 6px; cursor: pointer; transition: all 0.2s;';
                item.dataset.arrowIndex = arrow.index;
                
                const fromTitle = fromPlot.title || 'Untitled Plot';
                const toTitle = toPlot.title || 'Untitled Plot';
                
                item.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <input type="checkbox" class="arrow-checkbox" data-arrow-index="${arrow.index}" style="cursor: pointer;">
                        <div style="flex: 1;">
                            <strong style="color: rgba(100, 200, 255, 1);">${fromTitle}</strong>
                            <span style="color: rgba(255,255,255,0.5);">  </span>
                            <strong style="color: rgba(100, 200, 255, 1);">${toTitle}</strong>
                        </div>
                    </div>
                `;
                
                // Click handler
                item.onclick = (e) => {
                    if (e.target.classList.contains('arrow-checkbox')) return;
                    
                    const checkbox = item.querySelector('.arrow-checkbox');
                    if (e.shiftKey) {
                        // Shift+click: toggle selection
                        checkbox.checked = !checkbox.checked;
                    } else {
                        // Regular click: single select
                        document.querySelectorAll('.arrow-checkbox').forEach(cb => cb.checked = false);
                        checkbox.checked = true;
                    }
                    updateArrowSelection();
                };
                
                // Checkbox handler
                const checkbox = item.querySelector('.arrow-checkbox');
                checkbox.onclick = (e) => {
                    e.stopPropagation();
                    updateArrowSelection();
                };
                
                // Hover effect
                item.onmouseenter = () => {
                    item.style.background = 'rgba(255,255,255,0.1)';
                    item.style.borderColor = 'rgba(100, 200, 255, 0.3)';
                };
                item.onmouseleave = () => {
                    item.style.background = 'rgba(255,255,255,0.05)';
                    item.style.borderColor = 'rgba(255,255,255,0.1)';
                };
                
                listContainer.appendChild(item);
            });
            
            // Show modal
            document.getElementById('arrow-management-modal').style.display = 'flex';
        }
        
        function updateArrowSelection() {
            selectedArrows.clear();
            document.querySelectorAll('.arrow-checkbox:checked').forEach(checkbox => {
                selectedArrows.add(parseInt(checkbox.dataset.arrowIndex));
            });
        }
        
        function deleteSelectedArrows() {
            if (selectedArrows.size === 0) return;
            
            const data = plotsByYear[selectedYear];
            if (!data || !data.arrows) return;
            
            // Sort indices in descending order to delete from end
            const indicesToDelete = Array.from(selectedArrows).sort((a, b) => b - a);
            
            indicesToDelete.forEach(index => {
                data.arrows.splice(index, 1);
            });
            
            saveData();
            renderPlotGrid();
            closeArrowManagement();
        }
        
        function closeArrowManagement() {
            selectedArrows.clear();
            document.getElementById('arrow-management-modal').style.display = 'none';
        }
        
        function reorderEventUp(plotIndex, eventIndex) {
            const events = plotsByYear[selectedYear].plots[plotIndex].events;
            if (eventIndex > 0) {
                [events[eventIndex], events[eventIndex - 1]] = [events[eventIndex - 1], events[eventIndex]];
                renderPlotGrid();
                saveData();
            }
        }
        
        function reorderEventDown(plotIndex, eventIndex) {
            const events = plotsByYear[selectedYear].plots[plotIndex].events;
            if (eventIndex < events.length - 1) {
                [events[eventIndex], events[eventIndex + 1]] = [events[eventIndex + 1], events[eventIndex]];
                renderPlotGrid();
                saveData();
            }
        }
        
        function handleEventText(el, plotIndex, eventIndex) {
            const text = el.innerText || el.textContent || "";
            if (text.length > 500) {
                el.innerText = text.substring(0, 500);
                return;
            }
            plotsByYear[selectedYear].plots[plotIndex].events[eventIndex].text = text;
            
            const eventNode = el.closest('.event-node');
            const charCount = eventNode ? eventNode.querySelector('.char-count') : null;
            if (charCount) charCount.textContent = `${text.length}/500`;
            
            saveData();
        }
        
        function processCharacterNamesInEvent(plotIndex, eventIndex) {
            const eventNode = document.querySelector(`.event-node[data-plot-idx="${plotIndex}"][data-event-idx="${eventIndex}"]`);
            if (!eventNode) return;
            
            const input = eventNode.querySelector('.event-input');
            if (!input) return;
            
            const text = input.innerText || input.textContent || "";
            const highlighted = highlightCharacterNames(text);
            input.innerHTML = highlighted;
            
            attachCharacterNameHandlers();
        }
        
        async function openLightbox(plotIndex, eventIndex) {
            console.log(' openLightbox called:', {plotIndex, eventIndex});
            
            const ev = plotsByYear[selectedYear].plots[plotIndex].events[eventIndex];
            console.log(' Event data:', ev);
            
            if(!ev.img) {
                console.log(' No image, calling triggerImgUpload');
                triggerImgUpload(plotIndex, eventIndex);
                return;
            }
            
            lbContext = { pIdx: plotIndex, eIdx: eventIndex };
            
            if (ev.img.startsWith('indexeddb:')) {
                const imageKey = ev.img.replace('indexeddb:', '');
                try {
                    const blob = await getImage(imageKey);
                    if (blob) {
                        const blobUrl = URL.createObjectURL(blob);
                        document.getElementById('lightbox-img').src = blobUrl;
                        document.getElementById('lightbox').style.display = 'flex';
                    }
                } catch (error) {
                    console.error('Failed to load lightbox image:', error);
                    alert('Failed to load image');
                }
            } else {
                document.getElementById('lightbox-img').src = ev.img;
                document.getElementById('lightbox').style.display = 'flex';
            }
        }
        
        function deleteLightboxImage() {
            if(confirm("Remove image?")) {
                plotsByYear[selectedYear].plots[lbContext.pIdx].events[lbContext.eIdx].img = null;
                document.getElementById('lightbox').style.display = 'none';
                renderPlotGrid();
                saveData();
            }
        }
        
        function replaceLightboxImage() {
            triggerImgUpload(lbContext.pIdx, lbContext.eIdx);
            document.getElementById('lightbox').style.display = 'none';
        }
        
        function triggerImgUpload(plotIndex, eventIndex) {
            console.log(' triggerImgUpload called:', {plotIndex, eventIndex});
            
            // Store context for modal
            window.eventImageContext = { plotIndex, eventIndex };
            
            // Show event image modal
            const modal = document.getElementById('event-image-modal');
            console.log(' Modal element:', modal);
            modal.style.display = 'flex';
            
            const urlInput = document.getElementById('event-image-url');
            urlInput.value = '';
            urlInput.focus();
            
            console.log(' Modal should now be visible');
        }
        
        async function confirmEventImage() {
            const url = document.getElementById('event-image-url').value.trim();
            
            if (!window.eventImageContext) {
                console.error('No event image context');
                return;
            }
            
            const { plotIndex, eventIndex } = window.eventImageContext;
            
            if (!url) {
                alert('Please enter an image URL or upload a file');
                return;
            }
            
            // Use URL
            plotsByYear[selectedYear].plots[plotIndex].events[eventIndex].img = url;
            saveData();
            renderPlotGrid();
            closeEventImageModal();
        }
        
        async function handleEventImageUpload(input) {
            if (!input.files || !input.files[0]) return;
            
            const file = input.files[0];
            const { plotIndex, eventIndex } = window.eventImageContext;
            
            const imageKey = `event_${universeId}_${Date.now()}`;
            try {
                await storeImage(imageKey, file);
                plotsByYear[selectedYear].plots[plotIndex].events[eventIndex].img = `indexeddb:${imageKey}`;
                saveData();
                renderPlotGrid();
                closeEventImageModal();
                input.value = ''; // Clear file input
            } catch (error) {
                console.error('Failed to store image:', error);
                alert('Failed to store image. Please try a smaller file.');
            }
        }
        
        function closeEventImageModal() {
            document.getElementById('event-image-modal').style.display = 'none';
            document.getElementById('event-image-url').value = '';
            document.getElementById('event-image-file').value = '';
        }
        
        // Event resize handlers (updated for grid)
        function startEventResize(e, plotIndex, eventIndex) {
            e.preventDefault();
            e.stopPropagation();
            
            const eventNode = e.target.closest('.event-node');
            if (!eventNode) return;
            
            resizeState.active = true;
            resizeState.element = eventNode;
            resizeState.startX = e.clientX;
            resizeState.textContainer = eventNode.querySelector('.event-text-container');
            resizeState.imageContainer = eventNode.querySelector('.event-image-container');
            resizeState.startWidth = resizeState.imageContainer.offsetWidth;
            resizeState.pIdx = plotIndex;
            resizeState.eIdx = eventIndex;
            
            document.addEventListener('mousemove', handleEventResize);
            document.addEventListener('mouseup', stopEventResize);
            
            document.body.style.userSelect = 'none';
        }
        
        function stopEventResize() {
            if (!resizeState.active) return;
            
            if (resizeState.pIdx !== null && resizeState.eIdx !== null) {
                const event = plotsByYear[selectedYear].plots[resizeState.pIdx].events[resizeState.eIdx];
                const textWidth = resizeState.textContainer.offsetWidth;
                const imageWidth = resizeState.imageContainer.offsetWidth;
                
                event.textWidth = textWidth;
                event.imageWidth = imageWidth;
                
                saveData();
            }
            
            resizeState.active = false;
            resizeState.element = null;
            resizeState.pIdx = null;
            resizeState.eIdx = null;
            
            document.removeEventListener('mousemove', handleEventResize);
            document.removeEventListener('mouseup', stopEventResize);
            
            document.body.style.userSelect = '';
        }

        // Set Project Name from Universe
        const urlParams = new URLSearchParams(window.location.search);
        const universeId = urlParams.get('id');
        let currentUniverse = null;
        let projName = "UNTITLED PROJECT";
        let seriesName = "";

        if (universeId) {
            const universes = JSON.parse(localStorage.getItem('alphaline_universes') || '[]');
            currentUniverse = universes.find(u => u.id === parseInt(universeId));
            
            if (currentUniverse) {
                projName = currentUniverse.name || "UNTITLED PROJECT";
                seriesName = currentUniverse.series || "";
            }
        }

        // Display project name and series
        const displayHTML = seriesName 
            ? `<span style="font-size: 0.5rem; color: #666; display: block; margin-bottom: 2px;">${seriesName}</span>${projName}`
            : projName;
        document.getElementById('project-name-display').innerHTML = displayHTML;

        // Initialize currentUniverse with years array
        if (!currentUniverse) {
            currentUniverse = { years: [] };
        } else if (!currentUniverse.years) {
            currentUniverse.years = [];
        }

        function updateClock() {
            const now = new Date();
            
            // Get 12-hour time with AM/PM
            let hours = now.getHours();
            const ampm = hours >= 12 ? 'PM' : 'AM';
            hours = hours % 12;
            hours = hours ? hours : 12; // 0 should be 12
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');
            const time12hr = `${hours}:${minutes}:${seconds} ${ampm}`;
            
            // Get timezone info
            const timezoneName = Intl.DateTimeFormat().resolvedOptions().timeZone;
            const timezoneAbbr = new Date().toLocaleTimeString('en-US', { timeZoneName: 'short' }).split(' ').pop();
            
            // Calculate offset from PST (UTC-8 standard, UTC-7 daylight)
            const localOffset = -now.getTimezoneOffset() / 60; // Convert minutes to hours
            const pstOffset = -8; // PST is UTC-8 (standard time)
            const pdtOffset = -7; // PDT is UTC-7 (daylight time)
            
            // Determine if PST is currently observing daylight time
            const jan = new Date(now.getFullYear(), 0, 1);
            const jul = new Date(now.getFullYear(), 6, 1);
            const stdOffset = Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
            const isDST = now.getTimezoneOffset() < stdOffset;
            
            const currentPstOffset = isDST ? pdtOffset : pstOffset;
            const offsetFromPst = localOffset - currentPstOffset;
            const pstLabel = isDST ? 'PDT' : 'PST';
            
            let offsetText = '';
            if (offsetFromPst === 0) {
                offsetText = `(${pstLabel})`;
            } else if (offsetFromPst > 0) {
                offsetText = `(${pstLabel} +${offsetFromPst}hr)`;
            } else {
                offsetText = `(${pstLabel} ${offsetFromPst}hr)`;
            }
            
            const date = now.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' }).toUpperCase();
            
            document.getElementById('workspace-clock').innerHTML = `${time12hr} ${timezoneAbbr} ${offsetText}<br>${date}`;
        }
        setInterval(updateClock, 1000); updateClock();

        function exitWorkspace() {
            // Save all data before exiting
            saveData();
            console.log('Data saved before exit');
            
            // Send message to parent to restore header/footer
            window.parent.postMessage('RESTORE_FRAME', '*');
            
            // Small delay before navigation to allow save and frame restoration
            setTimeout(() => {
                window.location.href = 'universes.html';
            }, 150);
        }

        // Camera Controls
        const plane = document.getElementById('plane-container');
        const nodeGroup = document.getElementById('node-group');

        plane.onmousedown = (e) => {
            if (e.target.closest('.plot-node') || e.target.closest('.modal-overlay') || e.target.closest('.event-node') || e.target.closest('.synopsis-node') || e.target.closest('#timeline-hud') || e.target.closest('.workspace-header')) return;
            let sx = e.clientX - panX, sy = e.clientY - panY;
            plane.onmousemove = (me) => {
                panX = me.clientX - sx; panY = me.clientY - sy;
                updateGrid();
            };
        };
        window.onmouseup = () => plane.onmousemove = null;
        
        plane.onwheel = (e) => {
            if (e.target.closest('#timeline-hud')) return;
            e.preventDefault();
            
            const delta = e.deltaY < 0 ? 1.1 : 0.9;
            const oldZoom = gridZoom;
            gridZoom = Math.min(Math.max(0.1, gridZoom * delta), 3);
            
            // Calculate mouse position relative to plane center
            const rect = plane.getBoundingClientRect();
            const mouseX = e.clientX - rect.left - rect.width / 2;
            const mouseY = e.clientY - rect.top - rect.height / 2;
            
            // Adjust pan to zoom toward mouse position
            const zoomRatio = gridZoom / oldZoom - 1;
            panX -= (mouseX - panX) * zoomRatio;
            panY -= (mouseY - panY) * zoomRatio;
            
            updateGrid();
        };

        function updateGrid() {
            const b = 20 * gridZoom;
            plane.style.backgroundSize = `${b}px ${b}px`;
            plane.style.backgroundPosition = `${panX}px ${panY}px`;
            nodeGroup.style.transform = `translate(calc(-50% + ${panX}px), calc(-50% + ${panY}px)) scale(${gridZoom})`;
            
            // Redraw arrows after zoom/pan changes
            renderArrows();
        }

        // Center and zoom the node graph
        function resetGraphView() {
            // Focus on Episode node (with banner if exists) through Synopsis
            // This view remains fixed regardless of grid size below
            panX = 0;
            panY = -250; // Fixed offset to show Episode/Characters/Synopsis at top
            gridZoom = 0.65; // Zoom out to see full top section including banner
            updateGrid();
        }

        function centerViewOnColumn(colName) {
            // Center view on specific column
            const offsets = {
                'left': -400,   // Left column offset
                'main': 0,      // Center column
                'right': 400    // Right column offset
            };
            
            panX = offsets[colName] || 0;
            panY = 100; // Offset to show column content (below top nodes)
            gridZoom = 0.85; // Slightly zoomed in to focus on column
            updateGrid();
        }

        // Logic
        function ensureYearData(y) {
            if (!plotsByYear[y]) {
                plotsByYear[y] = { 
                    episodeTitle: "", 
                    synopsis: "", 
                    plots: [], 
                    arrows: [],
                    sceneCharacters: [] 
                };
            }
            // Ensure arrows array exists even if data was created before arrows feature
            if (!plotsByYear[y].arrows) {
                plotsByYear[y].arrows = [];
            }
        }

        // Event resize state
        let resizeState = {
            active: false,
            element: null,
            startX: 0,
            startWidth: 0,
            textContainer: null,
            imageContainer: null,
            pIdx: null,
            eIdx: null,
            col: null
        };


        function adjustEventFontSize(eventNode) {
            const textContainer = eventNode.querySelector('.event-text-container');
            const eventInput = eventNode.querySelector('.event-input');
            if (!textContainer || !eventInput) return;
            
            const containerWidth = textContainer.offsetWidth;
            
            // Scale font size based on container width
            // 562px (max text width at 55%) = 0.85rem (base)
            // 357px (min text width at 35%) = 0.65rem (smaller)
            const maxWidth = 562;
            const minWidth = 357;
            const maxFontSize = 0.85;
            const minFontSize = 0.65;
            
            let fontSize = maxFontSize;
            if (containerWidth < maxWidth) {
                const ratio = (containerWidth - minWidth) / (maxWidth - minWidth);
                fontSize = minFontSize + (ratio * (maxFontSize - minFontSize));
                fontSize = Math.max(minFontSize, Math.min(maxFontSize, fontSize));
            }
            
            eventInput.style.fontSize = `${fontSize}rem`;
        }
        
        function handleEventResize(e) {
            if (!resizeState.active) return;
            
            let deltaX = e.clientX - resizeState.startX;
            
            // When image is on right (NOT flipped): drag right = expand image (shrink text)
            // When image is on left (flipped): drag left = expand image (shrink text)
            const isFlipped = resizeState.element.classList.contains('flipped');
            if (!isFlipped) {
                deltaX = -deltaX;  // Invert for normal layout (image on right)
            }
            
            // Total available space: 704px (text + image, handle is separate)
            const totalAvailableWidth = 704;
            
            // Calculate new image width from drag
            let newImageWidth = resizeState.startWidth + deltaX;
            
            // Calculate corresponding text width
            let newTextWidth = totalAvailableWidth - newImageWidth;
            
            // ENFORCE LIMITS on BOTH sections to prevent overflow
            const minTextWidth = 154;   // Text must stay at least 154px
            const maxTextWidth = 550;   // Text cannot exceed 550px (THIS WAS THE MISSING LIMIT)
            const minImageWidth = 154;  // Image must stay at least 154px  
            const maxImageWidth = 550;  // Image cannot exceed 550px
            
            // Clamp TEXT width first (this prevents the overflow issue)
            newTextWidth = Math.max(minTextWidth, Math.min(maxTextWidth, newTextWidth));
            
            // Recalculate image width to match
            newImageWidth = totalAvailableWidth - newTextWidth;
            
            // Apply new widths
            resizeState.textContainer.style.flex = `0 0 ${newTextWidth}px`;
            resizeState.imageContainer.style.width = `${newImageWidth}px`;
        }

        function handleSynopsis(el) {
            if(selectedYear) {
                // Get text content from contenteditable div
                const text = el.innerText || el.textContent || "";
                plotsByYear[selectedYear].synopsis = text;
                saveData();
            }
        }
        
        function processCharacterNamesInSynopsis() {
            if (!selectedYear) return;
            const el = document.getElementById('synopsis-text');
            const text = el.innerText || el.textContent || "";
            
            // Apply both character and glossary highlighting
            const highlighted = highlightCharacterNames(text);
            
            // Always update if highlighting changed
            if (highlighted !== text) {
                el.innerHTML = highlighted;
                attachCharacterNameHandlers(); // This now also attaches glossary handlers
            }
        }
        
        function processCharacterNamesInEvent(pIdx, eIdx, col) {
            if (!selectedYear) return;
            
            const event = plotsByYear[selectedYear][col][pIdx].events[eIdx];
            if (!event) return;
            
            // Find the specific event input by traversing the DOM
            const plotWrappers = document.querySelectorAll('.plot-wrapper');
            plotWrappers.forEach(wrapper => {
                const eventInputs = wrapper.querySelectorAll('.event-input');
                eventInputs.forEach((eventNode, index) => {
                    // Check if this is the right event by comparing data or index
                    const text = eventNode.innerText || eventNode.textContent || "";
                    const highlighted = highlightCharacterNames(text);
                    
                    if (highlighted !== text) {
                        // Store cursor position
                        const selection = window.getSelection();
                        const range = selection.rangeCount > 0 ? selection.getRangeAt(0) : null;
                        const cursorOffset = range ? range.startOffset : 0;
                        
                        eventNode.innerHTML = highlighted;
                        attachCharacterNameHandlers();
                        
                        // Restore cursor position
                        try {
                            if (range && eventNode.firstChild) {
                                const newRange = document.createRange();
                                const textNode = eventNode.firstChild;
                                newRange.setStart(textNode, Math.min(cursorOffset, textNode.length));
                                newRange.collapse(true);
                                selection.removeAllRanges();
                                selection.addRange(newRange);
                            }
                        } catch (e) {
                            // Cursor restoration failed, no big deal
                        }
                    }
                });
            });
        }

        function handleEpisodeTitle(el) {
            if(selectedYear) {
                plotsByYear[selectedYear].episodeTitle = el.value;
                saveData();
            }
        }

        function addNewPlotNode(index, column) {
            if (!selectedYear) return;
            ensureYearData(selectedYear);
            plotsByYear[selectedYear][column].splice(index, 0, { title: 'Add Text', events: [] });
            renderPlotStack();
            saveData();
        }

        function appendPlotNode(column) {
            if (!selectedYear) return;
            ensureYearData(selectedYear);
            plotsByYear[selectedYear][column].push({ title: 'Add Text', events: [] });
            renderPlotStack();
            saveData();
        }

        function addEventToNode(pIdx, column) {
            plotsByYear[selectedYear][column][pIdx].events.push({ 
                text: '', 
                img: null, 
                flipped: false,
                textWidth: 420,  // Default width
                imageWidth: 284  // Default width
            });
            renderPlotStack();
            saveData();
        }
        
        // Grid visibility toggle
        let gridCellsVisible = true;
        
        function toggleEmptyGridCells() {
            gridCellsVisible = !gridCellsVisible;
            const grid = document.getElementById('plot-grid');
            
            if (gridCellsVisible) {
                grid.classList.remove('hide-empty-cells');
            } else {
                grid.classList.add('hide-empty-cells');
            }
            
            // Update eye icon
            const eyeIcon = document.getElementById('grid-toggle-eye');
            eyeIcon.textContent = gridCellsVisible ? '' : '';
            eyeIcon.title = gridCellsVisible ? 'Clean view (hide empty slots)' : 'Show empty slots';
        }
        
        // Grid visibility toggle
        function renderPlotGrid() {
            console.log(' renderPlotGrid called');
            const grid = document.getElementById('plot-grid');
            if (!grid) {
                console.error(' plot-grid element not found!');
                return;
            }
            
            ensureGridStructure();
            const data = plotsByYear[selectedYear];
            if (!data) {
                console.error(' No data for selectedYear:', selectedYear);
                return;
            }
            
            console.log(' Rendering grid with data:', {
                selectedYear,
                plotsCount: data.plots?.length || 0,
                plots: data.plots
            });
            
            // Clear and prepare grid
            grid.innerHTML = '';
            
            // Add SVG container for arrows (over entire plane, not just grid)
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('id', 'plot-arrows-svg');
            svg.style.position = 'fixed';
            svg.style.top = '0';
            svg.style.left = '0';
            svg.style.width = '100%';
            svg.style.height = '100%';
            svg.style.pointerEvents = 'none';
            svg.style.zIndex = '1000';
            
            // Add arrowhead marker (smaller and thinner)
            svg.innerHTML = `
                <defs>
                    <marker id="arrowhead" markerWidth="6" markerHeight="6" refX="5" refY="2" orient="auto">
                        <polygon points="0 0, 6 2, 0 4" fill="rgba(100, 200, 255, 0.7)" />
                    </marker>
                </defs>
            `;
            
            // Append to plane-container instead of grid
            document.getElementById('plane-container').appendChild(svg);
            
            // Calculate grid dimensions - expand in all directions
            let minCol = 0;
            let maxCol = 2;
            let maxRow = 2; // Minimum 3 rows
            
            if (data.plots.length > 0) {
                minCol = Math.min(...data.plots.map(p => p.col), 0);
                maxCol = Math.max(...data.plots.map(p => p.col), 2);
                maxRow = Math.max(...data.plots.map(p => p.row), 2);
                
                // Add extra column on right if rightmost is filled
                const rightmostFilled = data.plots.some(p => p.col === maxCol);
                if (rightmostFilled) maxCol++;
                
                // Add extra column on left if leftmost is filled
                const leftmostFilled = data.plots.some(p => p.col === minCol);
                if (leftmostFilled) minCol--;
                
                // Add extra row at bottom if bottom row is filled
                const bottomFilled = data.plots.some(p => p.row === maxRow);
                if (bottomFilled) maxRow++;
            }
            
            // Update grid template
            const numCols = maxCol - minCol + 1;
            grid.style.gridTemplateColumns = `repeat(${numCols}, 800px)`;
            
            // Create grid cells
            for (let row = 0; row <= maxRow; row++) {
                for (let col = minCol; col <= maxCol; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    
                    const plot = data.plots.find(p => p.row === row && p.col === col);
                    
                    if (plot) {
                        const plotIndex = data.plots.indexOf(plot);
                        cell.innerHTML = renderPlotNode(plot, plotIndex, row, col);
                    } else {
                        cell.classList.add('empty');
                        
                        // Add helper text to first middle cell if grid is empty
                        const isFirstMiddle = (row === 0 && col === 1 && data.plots.length === 0);
                        if (isFirstMiddle) {
                            cell.innerHTML = `
                                <div class="grid-add-btn">+</div>
                                <div class="grid-helper-text">CLICK HERE TO BEGIN</div>
                            `;
                        } else {
                            cell.innerHTML = '<div class="grid-add-btn">+</div>';
                        }
                        
                        cell.onclick = () => addPlotToGrid(row, col);
                    }
                    
                    cell.addEventListener('dragover', handleGridDragOver);
                    cell.addEventListener('drop', (e) => handleGridDrop(e, row, col));
                    cell.addEventListener('dragleave', handleGridDragLeave);
                    
                    grid.appendChild(cell);
                }
            }
            
            loadAllEventImages();
            
            // Adjust font sizes for all event nodes based on their widths
            document.querySelectorAll('.event-node').forEach(eventNode => {
                adjustEventFontSize(eventNode);
            });
            
            renderArrows();
            
            // Update connector visual indicators
            updateConnectorIndicators();
            
            // Pulse animation for empty grids
            if (data.plots.length === 0) {
                setTimeout(() => {
                    document.querySelectorAll('.grid-cell.empty').forEach(cell => {
                        cell.classList.add('pulse-animation');
                    });
                    
                    // Remove animation after it completes
                    setTimeout(() => {
                        document.querySelectorAll('.grid-cell.empty').forEach(cell => {
                            cell.classList.remove('pulse-animation');
                        });
                    }, 4500); // 1.5s * 3 iterations
                }, 100);
            }
        }
        
        function renderArrows() {
            const svg = document.getElementById('plot-arrows-svg');
            if (!svg) return;
            
            const data = plotsByYear[selectedYear];
            if (!data || !data.arrows) return;
            
            // Clear existing arrows (keep defs)
            const defs = svg.querySelector('defs');
            svg.innerHTML = '';
            if (defs) svg.appendChild(defs);
            
            // Use setTimeout to ensure DOM is updated
            setTimeout(() => {
                // Render each arrow
                data.arrows.forEach((arrow, arrowIdx) => {
                    const fromPlot = data.plots[arrow.fromPlotIndex];
                    const toPlot = data.plots[arrow.toPlotIndex];
                    
                    if (!fromPlot || !toPlot) return;
                    
                    // Find the actual connector elements
                    const fromConnector = document.querySelector(`.plot-connector.bottom[data-plot-idx="${arrow.fromPlotIndex}"]`);
                    const toConnector = document.querySelector(`.plot-connector.top[data-plot-idx="${arrow.toPlotIndex}"]`);
                    
                    if (!fromConnector || !toConnector) return;
                    
                    const fromRect = fromConnector.getBoundingClientRect();
                    const toRect = toConnector.getBoundingClientRect();
                    const svgRect = svg.getBoundingClientRect();
                    
                    // Calculate positions relative to SVG viewport
                    const x1 = fromRect.left - svgRect.left + fromRect.width / 2;
                    const y1 = fromRect.top - svgRect.top + fromRect.height / 2;
                    const x2 = toRect.left - svgRect.left + toRect.width / 2;
                    const y2 = toRect.top - svgRect.top + toRect.height / 2;
                    
                    // Create invisible thicker line for easier clicking
                    const hitbox = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    hitbox.setAttribute('x1', x1);
                    hitbox.setAttribute('y1', y1);
                    hitbox.setAttribute('x2', x2);
                    hitbox.setAttribute('y2', y2);
                    hitbox.setAttribute('stroke', 'transparent');
                    hitbox.setAttribute('stroke-width', '12');
                    hitbox.style.cursor = 'pointer';
                    hitbox.style.pointerEvents = 'stroke';
                    hitbox.onclick = (e) => {
                        e.stopPropagation();
                        deleteArrowDirect(arrowIdx);
                    };
                    
                    // Create visible arrow line
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', x1);
                    line.setAttribute('y1', y1);
                    line.setAttribute('x2', x2);
                    line.setAttribute('y2', y2);
                    line.setAttribute('stroke', 'rgba(100, 200, 255, 0.7)');
                    line.setAttribute('stroke-width', '2');
                    line.setAttribute('marker-end', 'url(#arrowhead)');
                    line.style.pointerEvents = 'none';
                    line.dataset.arrowIdx = arrowIdx;
                    
                    // Add hover effect on hitbox
                    hitbox.onmouseenter = () => {
                        line.setAttribute('stroke', 'rgba(100, 200, 255, 1)');
                        line.setAttribute('stroke-width', '3');
                    };
                    hitbox.onmouseleave = () => {
                        line.setAttribute('stroke', 'rgba(100, 200, 255, 0.7)');
                        line.setAttribute('stroke-width', '2');
                    };
                    
                    svg.appendChild(hitbox);
                    svg.appendChild(line);
                });
            }, 50);
        }
        
        function deleteArrowDirect(arrowIdx) {
            const data = plotsByYear[selectedYear];
            if (!data || !data.arrows || !data.arrows[arrowIdx]) return;
            
            // Delete immediately
            data.arrows.splice(arrowIdx, 1);
            saveData();
            renderPlotGrid();
        }
        
        let selectedArrowIndices = [];
        
        function openArrowManagement(plotIndex, connectorType) {
            const data = plotsByYear[selectedYear];
            if (!data || !data.arrows) return;
            
            const plot = data.plots[plotIndex];
            if (!plot) return;
            
            // Find all arrows connected to this connector
            let relevantArrows = [];
            
            if (connectorType === 'bottom') {
                // Outbound arrows (from this plot)
                relevantArrows = data.arrows
                    .map((arrow, idx) => ({...arrow, idx}))
                    .filter(arrow => arrow.fromPlotIndex === plotIndex);
            } else {
                // Inbound arrows (to this plot)
                relevantArrows = data.arrows
                    .map((arrow, idx) => ({...arrow, idx}))
                    .filter(arrow => arrow.toPlotIndex === plotIndex);
            }
            
            if (relevantArrows.length === 0) {
                showInvalidDestinationTooltip(
                    event.clientX, 
                    event.clientY, 
                    'No connections on this point'
                );
                return;
            }
            
            // Populate modal
            const modal = document.getElementById('arrow-management-modal');
            const description = document.getElementById('arrow-modal-description');
            const container = document.getElementById('arrow-list-container');
            
            const plotTitle = plot.title || 'Untitled Plot';
            if (connectorType === 'bottom') {
                description.textContent = `Outbound connections from: ${plotTitle}`;
            } else {
                description.textContent = `Inbound connections to: ${plotTitle}`;
            }
            
            // Clear previous selections
            selectedArrowIndices = [];
            container.innerHTML = '';
            
            // Create list items
            relevantArrows.forEach(arrow => {
                const fromPlot = data.plots[arrow.fromPlotIndex];
                const toPlot = data.plots[arrow.toPlotIndex];
                
                const item = document.createElement('div');
                item.className = 'arrow-list-item';
                item.dataset.arrowIdx = arrow.idx;
                
                const fromTitle = fromPlot ? (fromPlot.title || 'Untitled Plot') : 'Unknown';
                const toTitle = toPlot ? (toPlot.title || 'Untitled Plot') : 'Unknown';
                
                item.innerHTML = `
                    <span class="arrow-from">${fromTitle}</span>
                    <span class="arrow-arrow"></span>
                    <span class="arrow-to">${toTitle}</span>
                `;
                
                item.onclick = (e) => toggleArrowSelection(arrow.idx, e.shiftKey);
                container.appendChild(item);
            });
            
            modal.style.display = 'flex';
        }
        
        function toggleArrowSelection(arrowIdx, isShiftKey) {
            const item = document.querySelector(`.arrow-list-item[data-arrow-idx="${arrowIdx}"]`);
            if (!item) return;
            
            if (isShiftKey) {
                // Shift+click: toggle individual
                const index = selectedArrowIndices.indexOf(arrowIdx);
                if (index > -1) {
                    selectedArrowIndices.splice(index, 1);
                    item.classList.remove('selected');
                } else {
                    selectedArrowIndices.push(arrowIdx);
                    item.classList.add('selected');
                }
            } else {
                // Regular click: select all with same from/to
                const data = plotsByYear[selectedYear];
                const clickedArrow = data.arrows[arrowIdx];
                
                // Clear previous selections
                document.querySelectorAll('.arrow-list-item.selected').forEach(el => {
                    el.classList.remove('selected');
                });
                selectedArrowIndices = [];
                
                // Select all arrows with same from/to
                data.arrows.forEach((arrow, idx) => {
                    if (arrow.fromPlotIndex === clickedArrow.fromPlotIndex && 
                        arrow.toPlotIndex === clickedArrow.toPlotIndex) {
                        selectedArrowIndices.push(idx);
                        const matchItem = document.querySelector(`.arrow-list-item[data-arrow-idx="${idx}"]`);
                        if (matchItem) matchItem.classList.add('selected');
                    }
                });
            }
            
            // Update delete button state
            const deleteBtn = document.getElementById('delete-arrows-btn');
            deleteBtn.disabled = selectedArrowIndices.length === 0;
        }
        
        function deleteSelectedArrows() {
            if (selectedArrowIndices.length === 0) return;
            
            const data = plotsByYear[selectedYear];
            
            // Sort indices in descending order to delete from end first
            selectedArrowIndices.sort((a, b) => b - a);
            
            selectedArrowIndices.forEach(idx => {
                data.arrows.splice(idx, 1);
            });
            
            saveData();
            renderPlotGrid();
            cancelArrowManagement();
        }
        
        function cancelArrowManagement() {
            selectedArrowIndices = [];
            document.getElementById('arrow-management-modal').style.display = 'none';
        }
        
        function updateConnectorIndicators() {
            const data = plotsByYear[selectedYear];
            if (!data || !data.arrows) return;
            
            // Remove all indicators
            document.querySelectorAll('.plot-connector').forEach(conn => {
                conn.classList.remove('has-arrows');
            });
            
            // Add indicators to connectors with arrows
            data.arrows.forEach(arrow => {
                const fromConnector = document.querySelector(`.plot-connector.bottom[data-plot-idx="${arrow.fromPlotIndex}"]`);
                const toConnector = document.querySelector(`.plot-connector.top[data-plot-idx="${arrow.toPlotIndex}"]`);
                
                if (fromConnector) fromConnector.classList.add('has-arrows');
                if (toConnector) toConnector.classList.add('has-arrows');
            });
        }
        
        function renderPlotNode(plot, plotIndex, row, col) {
            const titleValue = plot.title || '';
            const titlePlaceholder = 'Add Text...';
            const isLocked = plot.locked || false;
            const lockIcon = isLocked ? '' : '';
            const lockTitle = isLocked ? 'Unlock plot' : 'Lock plot';
            const draggable = isLocked ? 'false' : 'true';
            const lockedClass = isLocked ? 'locked' : '';
            
            let eventsHTML = '';
            if (plot.events && plot.events.length > 0) {
                plot.events.forEach((ev, eIdx) => {
                    const flippedClass = ev.flipped ? 'flipped' : '';
                    const textLength = (ev.text || '').length;
                    
                    // Calculate font size based on text length to fit ~40 chars per line
                    // Start at 0.85rem, scale down as text gets longer
                    let fontSize = 0.85;
                    if (textLength > 200) fontSize = 0.75;
                    if (textLength > 300) fontSize = 0.7;
                    if (textLength > 400) fontSize = 0.65;
                    
                    eventsHTML += `
                        <div class="event-node ${flippedClass}" data-plot-idx="${plotIndex}" data-event-idx="${eIdx}">
                            <div class="event-reorder">
                                <div class="reorder-arrow up" onclick="reorderEventUp(${plotIndex}, ${eIdx}); event.stopPropagation();"></div>
                                <div class="reorder-arrow down" onclick="reorderEventDown(${plotIndex}, ${eIdx}); event.stopPropagation();"></div>
                            </div>
                            <div class="event-text-container" style="flex: 0 0 492px;">
                                <div class="event-tools">
                                    <div class="tool-btn" title="Flip Side" onclick="toggleEventSide(${plotIndex}, ${eIdx})"></div>
                                    <div class="tool-btn tool-delete" title="Delete Event" onclick="deleteEvent(${plotIndex}, ${eIdx})"></div>
                                </div>
                                <div class="event-input" contenteditable="true" data-maxlength="500" placeholder="Event description..." style="font-size: ${fontSize}rem;" oninput="handleEventText(this, ${plotIndex}, ${eIdx})" onblur="processCharacterNamesInEvent(${plotIndex}, ${eIdx})">${highlightCharacterNames(ev.text)}</div>
                                <div class="char-count">${textLength}/500</div>
                            </div>
                            <div class="event-image-container" data-image-ref="${ev.img || ''}" style="width: 212px; display: flex; align-items: center; justify-content: center;">
                                ${!ev.img ? `
                                    <div class="event-image-upload-btn" onclick="event.stopPropagation(); triggerImgUpload(${plotIndex}, ${eIdx})">UPLOAD IMG</div>
                                ` : ''}
                            </div>
                        </div>
                    `;
                });
            }
            
            return `
                <div class="plot-node-wrapper ${lockedClass}" draggable="${draggable}" data-plot-idx="${plotIndex}" data-row="${row}" data-col="${col}" ondragstart="handlePlotDragStart(event, ${plotIndex})" ondragend="handlePlotDragEnd(event)">
                    <div class="plot-connector top" data-plot-idx="${plotIndex}" data-connector="top" onmousedown="handleConnectorMouseDown(event, ${plotIndex}, 'top')" onclick="event.stopPropagation(); openArrowManagement(${plotIndex}, 'top');"></div>
                    <div class="plot-node">
                        <div class="plot-lock-icon" onclick="event.stopPropagation(); togglePlotLock(${plotIndex})" title="${lockTitle}">${lockIcon}</div>
                        <input class="plot-title-field" value="${titleValue}" placeholder="${titlePlaceholder}" oninput="updatePlotTitle(${plotIndex}, this.value)">
                        <div style="display:flex; flex-direction:column; gap:12px;">${eventsHTML}</div>
                        <button class="tm-btn" style="border-radius:8px; border:1px dashed #333;" onclick="addEventToPlot(${plotIndex})">+ Add ${subunitEvent}</button>
                    </div>
                    <div class="plot-connector bottom" data-plot-idx="${plotIndex}" data-connector="bottom" onmousedown="handleConnectorMouseDown(event, ${plotIndex}, 'bottom')" onclick="event.stopPropagation(); openArrowManagement(${plotIndex}, 'bottom');"></div>
                </div>
            `;
        }

        function renderPlotStack() {
            console.log(' renderPlotStack called, selectedYear:', selectedYear);
            const data = plotsByYear[selectedYear];
            if(!data) {
                console.error(' No data in renderPlotStack for year:', selectedYear);
                return;
            }
            
            console.log(' renderPlotStack data:', {
                episodeTitle: data.episodeTitle,
                plotsCount: data.plots?.length,
                synopsis: data.synopsis?.substring(0, 50)
            });

            // Episode Title
            const episodeTitleInput = document.getElementById('episode-title');
            episodeTitleInput.value = data.episodeTitle || "";

            // Synopsis
            const synBox = document.getElementById('synopsis-text');
            const synopsisText = data.synopsis || "";
            const highlighted = highlightCharacterNames(synopsisText);
            synBox.innerHTML = highlighted;
            attachCharacterNameHandlers();

            // Render grid instead of columns
            console.log(' About to call renderPlotGrid...');
            renderPlotGrid();
            
            // Attach handlers to all highlighted character names and glossary terms in events
            attachCharacterNameHandlers();
            
            // Render scene characters
            renderSceneCharacters();
            
            // Recalculate widths after rendering
            setTimeout(() => updateColumnWidths(), 50);
        }
        
        async function loadAllEventImages() {
            const imageContainers = document.querySelectorAll('.event-image-container[data-image-ref]');
            for (const container of imageContainers) {
                const imageRef = container.dataset.imageRef;
                if (!imageRef) continue;
                
                // Get plot and event indices from parent event node
                const eventNode = container.closest('.event-node');
                if (!eventNode) continue;
                
                const plotIndex = parseInt(eventNode.dataset.plotIdx);
                const eventIndex = parseInt(eventNode.dataset.eventIdx);
                
                if (imageRef.startsWith('indexeddb:')) {
                    const imageKey = imageRef.replace('indexeddb:', '');
                    try {
                        const blob = await getImage(imageKey);
                        if (blob) {
                            const blobUrl = URL.createObjectURL(blob);
                            const img = document.createElement('img');
                            img.src = blobUrl;
                            img.onclick = (e) => {
                                e.stopPropagation();
                                openLightbox(plotIndex, eventIndex);
                            };
                            container.innerHTML = '';
                            container.appendChild(img);
                        }
                    } catch (error) {
                        console.error('Failed to load event image:', error);
                    }
                } else {
                    // Regular URL
                    const img = document.createElement('img');
                    img.src = imageRef;
                    img.onclick = (e) => {
                        e.stopPropagation();
                        openLightbox(plotIndex, eventIndex);
                    };
                    container.innerHTML = '';
                    container.appendChild(img);
                }
            }
        }

        function renderColumn(containerId, plots, colName) {
            const stack = document.getElementById(containerId);
            stack.innerHTML = '';

            plots.forEach((plot, pIdx) => {
                const wrapper = document.createElement('div');
                wrapper.className = 'plot-node-wrapper draggable';
                wrapper.setAttribute('draggable', 'true');
                wrapper.dataset.index = pIdx;
                wrapper.dataset.col = colName;
                
                const node = document.createElement('div');
                node.className = 'plot-node';
                
                // Use placeholder for "Add Text" instead of value
                const titleValue = plot.title || '';
                const titlePlaceholder = 'Add Text...';
                
                node.innerHTML = `
                    <input class="plot-title-field" 
                           value="${titleValue}" 
                           placeholder="${titlePlaceholder}"
                           oninput="updatePlotTitle(${pIdx}, '${colName}', this.value)">
                    <div id="ev-container-${colName}-${pIdx}" style="display:flex; flex-direction:column; gap:12px;"></div>
                    <button class="tm-btn" style="border-radius:8px; border:1px dashed #333;" onclick="addEventToNode(${pIdx}, '${colName}')">+ Add ${subunitEvent}</button>
                `;

                // Events
                const evCont = node.querySelector(`#ev-container-${colName}-${pIdx}`);
                plot.events.forEach((ev, eIdx) => {
                    // Initialize default widths if not present (backwards compatibility)
                    if (!ev.textWidth) ev.textWidth = 562;
                    if (!ev.imageWidth) ev.imageWidth = 460;
                    
                    const evNode = document.createElement('div');
                    evNode.className = `event-node draggable ${ev.flipped ? 'flipped' : ''}`;
                    evNode.setAttribute('draggable', 'true');
                    evNode.dataset.pIdx = pIdx;
                    evNode.dataset.eIdx = eIdx;
                    evNode.dataset.col = colName;
                    
                    evNode.innerHTML = `
                        <div class="event-reorder">
                            <div class="reorder-arrow up" onclick="reorderEventUp(${pIdx}, ${eIdx}, '${colName}'); event.stopPropagation();"></div>
                            <div class="reorder-arrow down" onclick="reorderEventDown(${pIdx}, ${eIdx}, '${colName}'); event.stopPropagation();"></div>
                        </div>
                        <div class="event-text-container">
                            <div class="event-tools">
                                <div class="tool-btn" title="Flip Side" onclick="toggleEventSide(${pIdx}, ${eIdx}, '${colName}')"></div>
                                <div class="tool-btn tool-delete" title="Delete Event" onclick="deleteEvent(${pIdx}, ${eIdx}, '${colName}')"></div>
                            </div>
                            <div class="event-input" 
                                 contenteditable="true" 
                                 data-maxlength="500" 
                                 placeholder="Event description..." 
                                 oninput="handleEventText(this, ${pIdx}, ${eIdx}, '${colName}')"
                                 onblur="processCharacterNamesInEvent(${pIdx}, ${eIdx}, '${colName}')">${highlightCharacterNames(ev.text)}</div>
                            <div class="char-count">${ev.text.length}/500</div>
                        </div>
                        <div class="event-resize-handle" onmousedown="startEventResize(event, ${pIdx}, ${eIdx}, '${colName}')">
                            <div class="resize-triangle"></div>
                        </div>
                        <div class="event-image-container" data-image-ref="${ev.img || ''}" onclick="openLightbox(${pIdx}, ${eIdx}, '${colName}')">
                            ${ev.img ? '' : '<span class="img-placeholder">ADD MEDIA</span>'}
                        </div>
                    `;
                    setupDnD(evNode, 'event');
                    evCont.appendChild(evNode);
                    
                    // Apply saved widths
                    const textContainer = evNode.querySelector('.event-text-container');
                    const imageContainer = evNode.querySelector('.event-image-container');
                    
                    if (ev.textWidth && ev.imageWidth) {
                        textContainer.style.flex = `0 0 ${ev.textWidth}px`;
                        textContainer.style.minWidth = `${ev.textWidth}px`;
                        textContainer.style.maxWidth = `${ev.textWidth}px`;
                        
                        imageContainer.style.width = `${ev.imageWidth}px`;
                        imageContainer.style.minWidth = `${ev.imageWidth}px`;
                        imageContainer.style.maxWidth = `${ev.imageWidth}px`;
                    }
                    
                    // Auto-size textarea after DOM insertion
                    setTimeout(() => {
                        const textarea = evNode.querySelector('textarea');
                        autoSize(textarea);
                    }, 0);
                });

                setupDnD(wrapper, 'plot');
                wrapper.appendChild(node);

                // Connector Pipe + Add Button
                const pipe = document.createElement('div');
                pipe.className = 'node-pipe';
                pipe.innerHTML = `<div class="pipe-add" onclick="addNewPlotNode(${pIdx + 1}, '${colName}')">+</div>`;
                wrapper.appendChild(pipe);
                
                stack.appendChild(wrapper);
            });

            // Always show trailing (+) for creating new node - even if column is empty
            const trailingAdd = document.createElement('div');
            trailingAdd.className = 'view-center-circle';
            trailingAdd.style.marginTop = plots.length > 0 ? '20px' : '0px';
            trailingAdd.onclick = () => appendPlotNode(colName);
            trailingAdd.innerHTML = '+';
            trailingAdd.title = 'Add new plot node';
            stack.appendChild(trailingAdd);
        }


        // --- ACTIONS ---


        // --- LIGHTBOX ---


        // --- DRAG & DROP ---
        // Setup trash zone listeners ONCE on page load
        function initTrashZone() {
            const trash = document.getElementById('trash-zone');
            
            trash.addEventListener('dragenter', (e) => {
                if(dragType === 'plot') {
                    trash.classList.add('drag-over');
                }
            });
            
            trash.addEventListener('dragleave', () => {
                trash.classList.remove('drag-over');
            });
            
            trash.addEventListener('dragover', (e) => {
                if(dragType === 'plot') {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                }
            });
            
            trash.addEventListener('drop', (e) => {
                e.stopPropagation();
                e.preventDefault();
                
                if(dragType === 'plot') {
                    const plotIndex = parseInt(e.dataTransfer.getData('plotIndex'));
                    
                    // Show delete confirmation modal
                    pendingPlotDeletion = plotIndex;
                    document.getElementById('plot-delete-modal').style.display = 'flex';
                }
                
                trash.classList.remove('drag-over');
            });
        }
        
        function confirmDeletePlot() {
            if (pendingPlotDeletion !== null) {
                const data = plotsByYear[selectedYear];
                
                // Remove arrows connected to this plot
                removeArrowsForPlot(pendingPlotDeletion);
                
                // Delete the plot
                data.plots.splice(pendingPlotDeletion, 1);
                
                renderPlotGrid();
                saveData();
            }
            cancelDeletePlot();
        }
        
        function cancelDeletePlot() {
            pendingPlotDeletion = null;
            document.getElementById('plot-delete-modal').style.display = 'none';
        }
        
        // Arrow connector handlers
        function handleConnectorMouseDown(event, plotIndex, connectorType) {
            event.stopPropagation();
            event.preventDefault();
            
            if (connectorType !== 'bottom') return; // Only drag from bottom
            
            const data = plotsByYear[selectedYear];
            const plot = data.plots[plotIndex];
            
            draggingConnector = true;
            
            // Get the actual connector element position
            const connector = event.target;
            const rect = connector.getBoundingClientRect();
            
            connectorSource = {
                plotIndex: plotIndex,
                row: plot.row,
                col: plot.col,
                x: rect.left + rect.width / 2,
                y: rect.top + rect.height / 2
            };
            
            // Create preview line in fixed SVG
            let svg = document.getElementById('plot-arrows-svg');
            if (!svg) {
                svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('id', 'plot-arrows-svg');
                svg.style.position = 'fixed';
                svg.style.top = '0';
                svg.style.left = '0';
                svg.style.width = '100%';
                svg.style.height = '100%';
                svg.style.pointerEvents = 'none';
                svg.style.zIndex = '1000';
                
                svg.innerHTML = `
                    <defs>
                        <marker id="arrowhead" markerWidth="6" markerHeight="6" refX="5" refY="2" orient="auto">
                            <polygon points="0 0, 6 2, 0 4" fill="rgba(100, 200, 255, 0.7)" />
                        </marker>
                    </defs>
                `;
                
                document.getElementById('plane-container').appendChild(svg);
            }
            
            dragPreviewLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            dragPreviewLine.setAttribute('stroke', 'rgba(100, 200, 255, 0.5)');
            dragPreviewLine.setAttribute('stroke-width', '2');
            dragPreviewLine.setAttribute('stroke-dasharray', '6,3');
            dragPreviewLine.setAttribute('x1', connectorSource.x);
            dragPreviewLine.setAttribute('y1', connectorSource.y);
            dragPreviewLine.setAttribute('x2', connectorSource.x);
            dragPreviewLine.setAttribute('y2', connectorSource.y);
            svg.appendChild(dragPreviewLine);
            
            // Highlight valid drop targets (top connectors of plots in rows below)
            document.querySelectorAll('.plot-connector.top').forEach(connector => {
                const targetPlotIdx = parseInt(connector.dataset.plotIdx);
                const targetPlot = data.plots[targetPlotIdx];
                
                if (targetPlot && targetPlot.row > plot.row) {
                    connector.classList.add('drag-target');
                }
            });
            
            document.addEventListener('mousemove', handleConnectorMouseMove);
            document.addEventListener('mouseup', handleConnectorMouseUp);
        }
        
        function handleConnectorMouseMove(event) {
            if (!draggingConnector || !dragPreviewLine) return;
            
            // Update preview line endpoint to follow mouse (viewport coordinates)
            dragPreviewLine.setAttribute('x2', event.clientX);
            dragPreviewLine.setAttribute('y2', event.clientY);
        }
        
        function handleConnectorMouseUp(event) {
            if (!draggingConnector) return;
            
            // Remove preview line
            if (dragPreviewLine) {
                dragPreviewLine.remove();
                dragPreviewLine = null;
            }
            
            // Check if dropped on a valid top connector
            const target = event.target;
            
            if (target.classList.contains('plot-connector') && 
                target.classList.contains('top') && 
                target.classList.contains('drag-target')) {
                
                const targetPlotIdx = parseInt(target.dataset.plotIdx);
                
                // Create arrow
                const data = plotsByYear[selectedYear];
                if (!data.arrows) data.arrows = [];
                
                // Check if arrow already exists
                const exists = data.arrows.some(a => 
                    a.fromPlotIndex === connectorSource.plotIndex && 
                    a.toPlotIndex === targetPlotIdx
                );
                
                if (!exists) {
                    data.arrows.push({
                        fromPlotIndex: connectorSource.plotIndex,
                        toPlotIndex: targetPlotIdx
                    });
                    saveData();
                    renderPlotGrid();
                }
            } else {
                // Invalid drop - show tooltip
                showInvalidDestinationTooltip(event.clientX, event.clientY);
            }
            
            // Clean up
            draggingConnector = false;
            connectorSource = null;
            document.querySelectorAll('.plot-connector.drag-target').forEach(c => {
                c.classList.remove('drag-target');
            });
            document.removeEventListener('mousemove', handleConnectorMouseMove);
            document.removeEventListener('mouseup', handleConnectorMouseUp);
        }
        
        function showInvalidDestinationTooltip(x, y, message) {
            const tooltip = document.createElement('div');
            tooltip.style.position = 'fixed';
            tooltip.style.left = x + 'px';
            tooltip.style.top = y + 'px';
            tooltip.style.background = 'rgba(255, 100, 100, 0.95)';
            tooltip.style.color = 'white';
            tooltip.style.padding = '10px 15px';
            tooltip.style.borderRadius = '6px';
            tooltip.style.fontSize = '0.75rem';
            tooltip.style.zIndex = '10000';
            tooltip.style.pointerEvents = 'none';
            tooltip.style.whiteSpace = 'nowrap';
            tooltip.textContent = message || 'Invalid destination. Please select an inbound dot on a node from a lower row.';
            document.body.appendChild(tooltip);
            
            // Fade out and remove
            setTimeout(() => {
                tooltip.style.transition = 'opacity 0.3s';
                tooltip.style.opacity = '0';
                setTimeout(() => tooltip.remove(), 300);
            }, 2000);
        }
        
        // Remove arrows when plot is moved
        function removeArrowsForPlot(plotIndex) {
            const data = plotsByYear[selectedYear];
            if (!data.arrows) return;
            
            // Remove any arrows connected to this plot
            data.arrows = data.arrows.filter(arrow => 
                arrow.fromPlotIndex !== plotIndex && arrow.toPlotIndex !== plotIndex
            );
        }

        function setupDnD(el, type) {
            el.addEventListener('dragstart', (e) => {
                if(e.target.closest('.tool-btn')) return; 
                dragSrcEl = el;
                dragType = type;
                document.body.classList.add('global-dragging');
                el.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
            });
            
            el.addEventListener('dragover', (e) => {
                e.preventDefault();
                return false;
            });
            
            el.addEventListener('dragenter', () => el.classList.add('drag-over'));
            el.addEventListener('dragleave', () => el.classList.remove('drag-over'));

            el.addEventListener('drop', (e) => {
                e.stopPropagation();
                if (dragSrcEl !== el && dragType === type) {
                    if (type === 'plot') {
                        movePlot(dragSrcEl.dataset.col, parseInt(dragSrcEl.dataset.index), el.dataset.col, parseInt(el.dataset.index));
                    } else if (dragSrcEl.dataset.col === el.dataset.col && dragSrcEl.dataset.pIdx === el.dataset.pIdx) {
                         reorderEvents(el.dataset.col, parseInt(dragSrcEl.dataset.pIdx), parseInt(dragSrcEl.dataset.eIdx), parseInt(el.dataset.pIdx), parseInt(el.dataset.eIdx));
                    }
                }
                return false;
            });
            
            el.addEventListener('dragend', () => {
                document.body.classList.remove('global-dragging');
                document.querySelectorAll('.draggable, #trash-zone').forEach(d => d.classList.remove('dragging', 'drag-over'));
                dragSrcEl = null;
                dragType = null;
            });
        }

        function movePlot(fromCol, fromIdx, toCol, toIdx) {
            const [moved] = plotsByYear[selectedYear][fromCol].splice(fromIdx, 1);
            plotsByYear[selectedYear][toCol].splice(toIdx, 0, moved);
            renderPlotStack();
            saveData();
        }

        function reorderEvents(col, fP, fE, tP, tE) {
            const list = plotsByYear[selectedYear][col][fP].events;
            const [moved] = list.splice(fE, 1);
            list.splice(tE, 0, moved);
            renderPlotStack();
            saveData();
        }

        // --- HELPERS ---
        
        function processCharacterNamesInEvent(plotIndex, eventIndex) {
            if (!selectedYear) return;
            
            const eventNode = document.querySelector(`.event-node[data-plot-idx="${plotIndex}"][data-event-idx="${eventIndex}"]`);
            if (!eventNode) return;
            
            const input = eventNode.querySelector('.event-input');
            if (!input) return;
            
            const text = input.innerText || input.textContent || "";
            const highlighted = highlightCharacterNames(text);
            input.innerHTML = highlighted;
            
            attachCharacterNameHandlers();
        }

        function updateColumnWidths() {
            // All events are now fixed width: 420px text + 284px image = 704px
            const eventWidth = 704;
            
            ['left', 'main', 'right'].forEach(colName => {
                const column = document.getElementById(`col-${colName}`);
                if (!column) return;
                
                // Check if column has any events
                const hasEvents = column.querySelectorAll('.event-node').length > 0;
                const columnWidth = hasEvents ? eventWidth : 550;
                
                column.style.width = `${columnWidth}px`;
                
                // Offset side columns to prevent overlap (halved distance)
                if (colName === 'left') {
                    const offset = (columnWidth - 550) / 2;
                    column.style.transform = `translateX(-${offset}px) scale(0.95)`;
                    column.style.transformOrigin = 'top right';
                } else if (colName === 'right') {
                    const offset = (columnWidth - 550) / 2;
                    column.style.transform = `translateX(${offset}px) scale(0.95)`;
                    column.style.transformOrigin = 'top left';
                } else {
                    column.style.transform = 'scale(1)';
                }
            });
        }

        function autoSize(el) {
            el.style.height = 'auto';
            el.style.height = el.scrollHeight + 'px';
        }

        // --- TIMELINE NAV ---
        function toggleTimelineHud() {
            const hud = document.getElementById('timeline-hud');
            hud.classList.toggle('hidden');
            
            // Save state to localStorage
            const isHidden = hud.classList.contains('hidden');
            localStorage.setItem('timeline-hud-hidden', isHidden);
        }
        
        // Restore timeline HUD state on load
        function restoreTimelineHudState() {
            const isHidden = localStorage.getItem('timeline-hud-hidden') === 'true';
            if (isHidden) {
                document.getElementById('timeline-hud').classList.add('hidden');
            }
        }
        
        function openYearModal() { 
            document.getElementById('year-modal').style.display = 'flex';
            document.getElementById('year-input').focus();
        }
        
        function closeYearModal() { 
            document.getElementById('year-modal').style.display = 'none';
            document.getElementById('year-input').value = '';
        }
        
        function confirmNewYear() {
            const y = parseInt(document.getElementById('year-input').value);
            const errorDiv = document.getElementById('year-error');
            const inputField = document.getElementById('year-input');
            
            if (isNaN(y)) return;
            
            if (currentUniverse.years.includes(y)) {
                // Episode already exists
                errorDiv.textContent = 'Episode number already exists!';
                errorDiv.style.opacity = '1';
                inputField.value = '';
                
                // Fade out after 2 seconds
                setTimeout(() => {
                    errorDiv.style.opacity = '0';
                }, 2000);
                return;
            }
            
            const isFirstYear = currentUniverse.years.length === 0;
            
            currentUniverse.years.push(y);
            currentUniverse.years.sort((a,b)=>a-b);
            ensureYearData(y);
            selectYear(y);
            
            // Hide empty state message when first episode is created
            if(isFirstYear) {
                hideEmptyStateMessage();
                setTimeout(() => resetGraphView(), 100);
            }
            
            closeYearModal();
        }

        function selectYear(y) {
            console.log(' selectYear called with:', y);
            selectedYear = y;
            ensureYearData(y);
            
            const data = plotsByYear[selectedYear];
            console.log(' Year data:', data);
            
            const displayEl = document.getElementById('grid-year-display');
            displayEl.innerText = y;
            
            // Auto-resize based on text length
            const textLength = y.toString().length;
            if (textLength > 4) {
                displayEl.classList.add('shrink');
            } else {
                displayEl.classList.remove('shrink');
            }
            
            document.getElementById('node-group').style.display = 'flex';
            hideEmptyStateMessage(); // Hide landing prompt when episode selected
            renderTimeline();
            renderPlotStack();
            updateEpisodeBanner();
            saveData();
        }
        
        function handleEpisodeNodeClick(event) {
            // Don't trigger if clicking on input field
            if (event.target.id === 'episode-title') return;
            
            openBannerModal();
        }
        
        async function handleBannerUpload(input) {
            if (!input.files || !input.files[0]) return;
            
            const file = input.files[0];
            
            try {
                // Store in IndexedDB
                const imageKey = `banner_${selectedYear}_${Date.now()}`;
                await storeImage(imageKey, file);
                
                // Set reference in modal
                document.getElementById('banner-url-input').value = `indexeddb:${imageKey}`;
                
                // Clear file input
                input.value = '';
            } catch (error) {
                console.error('Error uploading banner:', error);
                alert('Failed to upload image. Please try again.');
            }
        }
        
        function openBannerModal() {
            const data = plotsByYear[selectedYear];
            const bannerRef = data.bannerRef || '';
            document.getElementById('banner-url-input').value = bannerRef;
            document.getElementById('banner-modal').style.display = 'flex';
        }
        
        function closeBannerModal() {
            document.getElementById('banner-modal').style.display = 'none';
            document.getElementById('banner-url-input').value = '';
        }
        
        async function confirmBanner() {
            const ref = document.getElementById('banner-url-input').value.trim();
            const data = plotsByYear[selectedYear];
            
            if (ref) {
                data.bannerRef = ref;
            } else {
                delete data.bannerRef;
            }
            
            await updateEpisodeBanner();
            saveData();
            closeBannerModal();
        }
        
        async function clearBanner() {
            const data = plotsByYear[selectedYear];
            
            // Delete from IndexedDB if it's a stored image
            if (data.bannerRef && data.bannerRef.startsWith('indexeddb:')) {
                const imageKey = data.bannerRef.replace('indexeddb:', '');
                await deleteImage(imageKey);
            }
            
            delete data.bannerRef;
            await updateEpisodeBanner();
            saveData();
            closeBannerModal();
        }
        
        async function updateEpisodeBanner() {
            const data = plotsByYear[selectedYear];
            const episodeNode = document.getElementById('episode-node');
            
            if (!episodeNode) return;
            
            // Remove existing banner if any
            const existingBanner = episodeNode.querySelector('.grid-node-banner');
            if (existingBanner) {
                existingBanner.remove();
            }
            
            if (data.bannerRef) {
                let imageUrl = data.bannerRef;
                
                // If IndexedDB reference, load the blob
                if (data.bannerRef.startsWith('indexeddb:')) {
                    const imageKey = data.bannerRef.replace('indexeddb:', '');
                    try {
                        const blob = await getImage(imageKey);
                        if (blob) {
                            imageUrl = URL.createObjectURL(blob);
                        } else {
                            console.warn('Banner image not found in IndexedDB');
                            return;
                        }
                    } catch (error) {
                        console.error('Error loading banner:', error);
                        return;
                    }
                }
                
                // Add banner class
                episodeNode.classList.add('has-banner');
                
                // Create banner element
                const banner = document.createElement('div');
                banner.className = 'grid-node-banner';
                banner.style.backgroundImage = `url(${imageUrl})`;
                episodeNode.insertBefore(banner, episodeNode.firstChild);
            } else {
                // Remove banner class
                episodeNode.classList.remove('has-banner');
            }
        }

        function renderTimeline() {
            const bar = document.getElementById('timeline-bar');
            bar.innerHTML = '<div class="timeline-axis"></div>';
            
            const centerBtn = document.getElementById('center-btn');
            const deleteEpisodeSetting = document.getElementById('delete-episode-setting');
            
            if (currentUniverse.years.length === 0) {
                if (deleteEpisodeSetting) deleteEpisodeSetting.style.display = 'none';
                centerBtn.style.display = 'none';
                return;
            }
            
            // Show center button when years exist
            centerBtn.style.display = 'inline-block';
            
            const min = Math.min(...currentUniverse.years);
            const max = Math.max(...currentUniverse.years);
            const range = max - min || 1;
            
            // Min/Max labels (clickable with preview)
            const minBox = document.createElement('div');
            minBox.className = 'year-box box-min';
            minBox.innerText = min;
            minBox.onclick = () => selectYear(min);
            minBox.onmouseenter = (e) => showEpisodePreview(min, e);
            minBox.onmouseleave = () => hideEpisodePreview();
            minBox.onmousemove = (e) => updateEpisodePreview(e);
            bar.appendChild(minBox);
            
            const maxBox = document.createElement('div');
            maxBox.className = 'year-box box-max';
            maxBox.innerText = max;
            maxBox.onclick = () => selectYear(max);
            maxBox.onmouseenter = (e) => showEpisodePreview(max, e);
            maxBox.onmouseleave = () => hideEpisodePreview();
            maxBox.onmousemove = (e) => updateEpisodePreview(e);
            bar.appendChild(maxBox);
            
            currentUniverse.years.forEach((year, index) => {
                let pos;
                
                if (isDistributed) {
                    // Evenly distribute years across timeline
                    const numYears = currentUniverse.years.length;
                    if (numYears === 1) {
                        pos = 50; // Center single year
                    } else {
                        // Space evenly from 0 to 100
                        pos = (index / (numYears - 1)) * 100;
                    }
                } else {
                    // Chronological distribution based on actual year values
                    pos = ((year - min) / range) * 100;
                }
                
                const isSelected = year === selectedYear;
                
                // Create marker (line or dot)
                const marker = document.createElement('div');
                marker.className = `year-line ${isSelected ? 'selected-marker' : ''}`;
                marker.style.left = `${pos}%`;
                marker.onclick = () => selectYear(year);
                
                // Create year box (hidden by default for middle items)
                const yearBox = document.createElement('div');
                yearBox.className = 'year-box box-above';
                yearBox.innerText = year;
                yearBox.onclick = (e) => {
                    e.stopPropagation();
                    selectYear(year);
                };
                
                // Hover behavior with 1s delay
                let hoverTimeout;
                let hideTimeout;
                
                marker.addEventListener('mouseenter', (e) => {
                    clearTimeout(hideTimeout);
                    hoverTimeout = setTimeout(() => {
                        yearBox.classList.add('show');
                    }, 100); // Small delay to show
                    showEpisodePreview(year, e);
                });
                
                marker.addEventListener('mouseleave', () => {
                    clearTimeout(hoverTimeout);
                    hideTimeout = setTimeout(() => {
                        yearBox.classList.remove('show');
                    }, 1000); // 1s delay to hide
                    hideEpisodePreview();
                });
                
                marker.addEventListener('mousemove', (e) => {
                    updateEpisodePreview(e);
                });
                
                yearBox.addEventListener('mouseenter', (e) => {
                    clearTimeout(hideTimeout);
                    yearBox.classList.add('show');
                    showEpisodePreview(year, e);
                });
                
                yearBox.addEventListener('mouseleave', () => {
                    hideTimeout = setTimeout(() => {
                        yearBox.classList.remove('show');
                    }, 1000); // 1s delay to hide
                    hideEpisodePreview();
                });
                
                yearBox.addEventListener('mousemove', (e) => {
                    updateEpisodePreview(e);
                });
                
                marker.appendChild(yearBox);
                bar.appendChild(marker);
            });
            
            // Show/hide delete button in settings
            if (deleteEpisodeSetting) {
                deleteEpisodeSetting.style.display = selectedYear ? 'block' : 'none';
            }
        }
        
        function toggleDistribution() {
            isDistributed = !isDistributed;
            renderTimeline();
        }
        
        function openSettingsModal() {
            document.getElementById('settings-overlay').style.display = 'flex';
            // Update toggle to reflect current theme
            updateThemeToggleUI();
            // Update timeline unit input
            document.getElementById('timeline-unit-input').value = timelineUnit;
            // Update subunit inputs
            document.getElementById('subunit-plot-input').value = subunitPlot;
            document.getElementById('subunit-event-input').value = subunitEvent;
        }

        function closeSettingsModal() {
            document.getElementById('settings-overlay').style.display = 'none';
        }

        function updateSubunits() {
            subunitPlot = document.getElementById('subunit-plot-input').value || "Plot";
            subunitEvent = document.getElementById('subunit-event-input').value || "Event";
            
            // Save to universe data
            saveData();
            
            // Update all UI elements with new terminology
            updateSubunitUI();
        }

        function updateSubunitUI() {
            // Update "Add Plot" buttons in renderColumn
            document.querySelectorAll('button[onclick*="addEventToNode"]').forEach(btn => {
                btn.innerText = `+ Add ${subunitEvent}`;
            });
            
            // Re-render to update plot title placeholders
            if (selectedYear) {
                renderPlotStack();
            }
        }

        function updateTimelineUnit(newUnit) {
            timelineUnit = newUnit || "Episode";
            
            // Save to universe data
            saveData();
            
            // Update all UI elements with new terminology
            updateTimelineUnitUI();
        }

        function updateTimelineUnitUI() {
            // Update "New Episode" button
            const newBtn = document.querySelector('button[onclick="openYearModal()"]');
            if (newBtn) {
                newBtn.innerText = `New ${timelineUnit}`;
            }
            
            // Update "Delete Episode" button
            const deleteBtn = document.getElementById('delete-btn');
            if (deleteBtn) {
                deleteBtn.innerHTML = `Delete ${timelineUnit}`;
            }
            
            // Update Episode node label
            const episodeLabel = document.querySelector('.grid-node .node-label');
            if (episodeLabel) {
                episodeLabel.innerText = timelineUnit;
            }
            
            // Update Episode title placeholder
            const episodeInput = document.getElementById('episode-title');
            if (episodeInput) {
                episodeInput.placeholder = `${timelineUnit} Title`;
            }
            
            // Update modal title
            const modalTitle = document.querySelector('.modal-title');
            if (modalTitle) {
                modalTitle.innerText = `${timelineUnit} Number`;
            }
            
            // Update character detail buttons
            updateCharacterButtonLabels();
        }

        function updateCharacterButtonLabels() {
            const addBtn = document.getElementById('add-to-episode-btn');
            if (addBtn) {
                const currentText = addBtn.innerText;
                if (currentText.includes('Add Character to')) {
                    addBtn.innerText = `Add Character to ${timelineUnit}`;
                } else if (currentText.includes('Remove Character from')) {
                    addBtn.innerText = `Remove Character from ${timelineUnit}`;
                } else if (currentText.includes('Character Added to')) {
                    addBtn.innerText = `Character Added to ${timelineUnit}`;
                } else if (currentText.includes('No') && currentText.includes('Selected')) {
                    addBtn.innerText = `No ${timelineUnit} Selected`;
                }
            }
        }

        function setThemeMode(mode) {
            // Remove all theme classes
            document.body.classList.remove('theme-dark', 'theme-light', 'theme-dark-on-light', 'theme-light-on-dark');
            
            // Add selected theme class
            if (mode !== 'dark') {
                document.body.classList.add(`theme-${mode}`);
            }
            
            // Save preference
            localStorage.setItem('alphaline_theme', mode);
            
            // Update UI
            updateThemeToggleUI();
        }

        function updateThemeToggleUI() {
            const currentTheme = getCurrentTheme();
            const toggle = document.querySelector('.theme-toggle-4way');
            const options = document.querySelectorAll('.theme-option');
            
            if (toggle) {
                toggle.setAttribute('data-active', currentTheme);
            }
            
            options.forEach(option => {
                if (option.dataset.theme === currentTheme) {
                    option.classList.add('active');
                } else {
                    option.classList.remove('active');
                }
            });
        }

        function getCurrentTheme() {
            if (document.body.classList.contains('theme-light')) return 'light';
            if (document.body.classList.contains('theme-dark-on-light')) return 'dark-on-light';
            if (document.body.classList.contains('theme-light-on-dark')) return 'light-on-dark';
            return 'dark';
        }

        // Load theme preference on page load
        function loadThemePreference() {
            const savedTheme = localStorage.getItem('alphaline_theme') || 'dark';
            setThemeMode(savedTheme);
        }

        // --- CHARACTER JOURNAL ---
        function openCharacterJournal() {
            document.getElementById('character-overlay').style.display = 'flex';
            renderCharacterList();
        }

        function closeCharacterJournal() {
            document.getElementById('character-overlay').style.display = 'none';
            closeCharacterDetail(); // Also close detail section
        }

        async function renderCharacterList() {
            const list = document.getElementById('character-list');
            list.innerHTML = '';

            // Render existing characters
            for (const char of characters) {
                const profile = document.createElement('div');
                profile.className = 'character-profile';
                profile.dataset.charId = char.id;
                
                // Load image (handle IndexedDB)
                let imageUrl = '';
                if (char.image) {
                    if (char.image.startsWith('indexeddb:')) {
                        const imageKey = char.image.replace('indexeddb:', '');
                        try {
                            const blob = await getImage(imageKey);
                            if (blob) {
                                imageUrl = URL.createObjectURL(blob);
                            }
                        } catch (error) {
                            console.error('Failed to load character avatar:', error);
                        }
                    } else {
                        imageUrl = char.image;
                    }
                }
                
                const avatarStyle = imageUrl ? `background-image: url('${imageUrl}');` : '';
                const avatarBorder = char.color ? `border-color: ${char.color};` : '';
                
                profile.innerHTML = `
                    <div class="character-avatar" style="${avatarStyle} ${avatarBorder}"></div>
                    <div class="character-name">${char.name}</div>
                `;

                // Click to show detail view
                profile.addEventListener('click', () => {
                    showCharacterDetail(char.id);
                });

                list.appendChild(profile);
            }

            // Add "+" button
            const addBtn = document.createElement('div');
            addBtn.className = 'add-character-btn';
            addBtn.innerHTML = '+';
            addBtn.onclick = () => createNewCharacter();
            list.appendChild(addBtn);
        }

        function createNewCharacter() {
            const newChar = {
                id: Date.now(),
                name: "Unnamed Character",
                aliases: [],
                status: "Unknown",
                bio: "",
                image: null,
                color: "#888888"
            };

            characters.push(newChar);
            saveData();
            openCharacterEditor(newChar.id);
        }

        // --- CHARACTER EDITOR ---
        async function openCharacterEditor(charId) {
            editingCharacterId = charId;
            const char = characters.find(c => c.id === charId);
            if (!char) return;

            document.getElementById('editor-title').innerText = char.name === "Unnamed Character" ? "NEW CHARACTER" : "EDIT CHARACTER";
            document.getElementById('char-name').value = char.name;
            document.getElementById('char-aliases').value = char.aliases.join(', ');
            document.getElementById('char-status').value = char.status;
            document.getElementById('char-bio').value = char.bio || "";
            
            // Set image URL - show user-friendly text for IndexedDB
            const imgUrlInput = document.getElementById('char-img-url');
            if (char.image && char.image.startsWith('indexeddb:')) {
                imgUrlInput.value = char.image; // Keep the reference for saving
                imgUrlInput.placeholder = "Local image uploaded";
            } else {
                imgUrlInput.value = char.image || "";
                imgUrlInput.placeholder = "Or URL";
            }
            
            // Set color picker
            const colorPicker = document.getElementById('char-color');
            colorPicker.value = char.color || "#888888";
            
            await updateCharacterPreview(char.image);
            updateColorPreview(char.color || "#888888");
            
            // Update appearances list
            updateCharacterAppearances(charId);

            document.getElementById('character-editor-overlay').style.display = 'flex';
        }

        function updateCharacterAppearances(charId) {
            // Find which episodes this character appears in
            const appearingEpisodes = [];
            Object.keys(plotsByYear).forEach(year => {
                const scene = plotsByYear[year];
                if (scene.sceneCharacters && scene.sceneCharacters.includes(charId)) {
                    appearingEpisodes.push(year);
                }
            });
            
            const appearsList = document.getElementById('char-appears-list');
            const appearsUnit = document.getElementById('char-appears-unit');
            
            appearsUnit.innerText = timelineUnit;
            
            if (appearingEpisodes.length > 0) {
                appearsList.innerText = appearingEpisodes.sort((a,b) => a-b).join(', ');
                appearsList.style.color = '#aaa';
            } else {
                appearsList.innerText = 'None';
                appearsList.style.color = '#666';
            }
        }

        function closeCharacterEditor() {
            if (editingCharacterId) {
                // Check if character is still default/unmodified
                const char = characters.find(c => c.id === editingCharacterId);
                if (char) {
                    const isUnmodified = 
                        char.name === "Unnamed Character" &&
                        char.aliases.length === 0 &&
                        char.status === "Unknown" &&
                        (!char.bio || char.bio.trim() === "") &&
                        (!char.image || char.image === null) &&
                        char.color === "#888888";
                    
                    if (isUnmodified) {
                        // Auto-delete unmodified character
                        characters = characters.filter(c => c.id !== editingCharacterId);
                        saveData();
                        renderCharacterList();
                    }
                }
            }
            
            document.getElementById('character-editor-overlay').style.display = 'none';
            
            // Update character timeline node to reflect changes
            renderSceneCharacters();
            
            // If we were viewing a character detail, go back to it
            if (selectedCharacterId) {
                showCharacterDetail(selectedCharacterId);
            } else {
                editingCharacterId = null;
                renderCharacterList();
            }
        }

        function autoSaveCharacter() {
            if (!editingCharacterId) return;

            const char = characters.find(c => c.id === editingCharacterId);
            if (!char) return;

            const oldName = char.name;
            char.name = document.getElementById('char-name').value || "Unnamed Character";
            char.aliases = document.getElementById('char-aliases').value.split(',').map(a => a.trim()).filter(a => a);
            char.status = document.getElementById('char-status').value;
            char.bio = document.getElementById('char-bio').value;
            
            // Get image URL from input
            const imgUrlInput = document.getElementById('char-img-url');
            char.image = imgUrlInput.value || null;
            
            // Get color from picker
            const colorPicker = document.getElementById('char-color');
            char.color = colorPicker.value || "#888888";

            updateCharacterPreview(char.image);
            updateColorPreview(char.color);

            saveData();
            
            // Re-process character names if name or color changed
            if (oldName !== char.name || char.color) {
                processCharacterNamesInSynopsis();
                renderPlotStack(); // This will re-highlight all events
            }
        }

        async function updateCharacterPreview(imgUrl) {
            const img = document.getElementById('char-preview-img');
            const placeholder = document.getElementById('char-placeholder');
            
            if (imgUrl && imgUrl.trim() !== "") {
                // Check if it's an IndexedDB reference
                if (imgUrl.startsWith('indexeddb:')) {
                    const imageKey = imgUrl.replace('indexeddb:', '');
                    try {
                        const blob = await getImage(imageKey);
                        if (blob) {
                            const blobUrl = URL.createObjectURL(blob);
                            img.src = blobUrl;
                            img.classList.add('visible');
                            placeholder.style.display = 'none';
                            
                            // Update detail popup avatar if it's showing
                            const detailAvatar = document.getElementById('detail-avatar');
                            if (detailAvatar && selectedCharacterId === editingCharacterId) {
                                detailAvatar.style.backgroundImage = `url('${blobUrl}')`;
                            }
                        }
                    } catch (error) {
                        console.error('Failed to load image from IndexedDB:', error);
                        img.classList.remove('visible');
                        placeholder.style.display = 'flex';
                    }
                } else {
                    // Regular URL
                    img.src = imgUrl;
                    img.classList.add('visible');
                    placeholder.style.display = 'none';
                    
                    // Update detail popup avatar if it's showing
                    const detailAvatar = document.getElementById('detail-avatar');
                    if (detailAvatar && selectedCharacterId === editingCharacterId) {
                        detailAvatar.style.backgroundImage = `url('${imgUrl}')`;
                    }
                }
            } else {
                img.classList.remove('visible');
                placeholder.style.display = 'flex';
                
                // Clear detail popup avatar if it's showing
                const detailAvatar = document.getElementById('detail-avatar');
                if (detailAvatar && selectedCharacterId === editingCharacterId) {
                    detailAvatar.style.backgroundImage = 'none';
                }
            }
        }

        function updateColorPreview(color) {
            document.getElementById('color-preview').style.backgroundColor = color;
            
            // Update detail popup avatar border if it's showing
            const detailAvatar = document.getElementById('detail-avatar');
            if (detailAvatar && selectedCharacterId === editingCharacterId) {
                detailAvatar.style.borderColor = color;
            }
        }

        async function handleCharacterImageUpload(input) {
            const file = input.files[0];
            if (!file) return;
            
            // Store in IndexedDB
            const imageKey = `char_${editingCharacterId}_${Date.now()}`;
            try {
                await storeImage(imageKey, file);
                
                // Store reference in character data
                const urlInput = document.getElementById('char-img-url');
                urlInput.value = `indexeddb:${imageKey}`;
                urlInput.placeholder = "Local image uploaded";
                
                autoSaveCharacter();
                
                // Create blob URL for immediate preview
                const blobUrl = URL.createObjectURL(file);
                const previewImg = document.getElementById('char-preview-img');
                const placeholder = document.getElementById('char-placeholder');
                
                previewImg.src = blobUrl;
                previewImg.classList.add('visible');
                placeholder.style.display = 'none';
                
                // Also update character list avatar if journal is open
                renderCharacterList();
            } catch (error) {
                console.error('Failed to store image:', error);
                alert('Failed to store image. Please try a smaller file or use an image URL instead.');
            }
        }

        // --- CHARACTER DETAIL VIEW ---
        let selectedCharacterId = null;

        async function showCharacterDetail(charId) {
            selectedCharacterId = charId;
            const char = characters.find(c => c.id === charId);
            if (!char) return;

            const detailPopup = document.getElementById('character-detail-popup');
            
            // Show detail popup and remove any fading state
            detailPopup.classList.remove('fading');
            detailPopup.classList.add('active');

            // Set avatar
            const avatar = document.getElementById('detail-avatar');
            if (char.image) {
                // Check if it's an IndexedDB reference
                if (char.image.startsWith('indexeddb:')) {
                    const imageKey = char.image.replace('indexeddb:', '');
                    try {
                        const blob = await getImage(imageKey);
                        if (blob) {
                            const blobUrl = URL.createObjectURL(blob);
                            avatar.style.backgroundImage = `url('${blobUrl}')`;
                        }
                    } catch (error) {
                        console.error('Failed to load image from IndexedDB:', error);
                        avatar.style.backgroundImage = 'none';
                    }
                } else {
                    avatar.style.backgroundImage = `url('${char.image}')`;
                }
            } else {
                avatar.style.backgroundImage = 'none';
            }
            avatar.style.borderColor = char.color || '#333';

            // Set name
            document.getElementById('detail-name').innerText = char.name;

            // Update appears-in list
            const appearingEpisodes = [];
            Object.keys(plotsByYear).forEach(year => {
                const scene = plotsByYear[year];
                if (scene.sceneCharacters && scene.sceneCharacters.includes(charId)) {
                    appearingEpisodes.push(year);
                }
            });
            
            const appearsList = document.getElementById('detail-appears-list');
            if (appearingEpisodes.length > 0) {
                appearsList.innerText = appearingEpisodes.sort((a,b) => a-b).join(', ');
            } else {
                appearsList.innerText = 'None';
            }

            // Update button state
            updateAddToEpisodeButton();
        }

        function closeCharacterDetail() {
            const detailPopup = document.getElementById('character-detail-popup');
            detailPopup.classList.remove('active', 'fading');
            selectedCharacterId = null;
        }

        function updateAddToEpisodeButton() {
            const btn = document.getElementById('add-to-episode-btn');
            if (!selectedYear || !plotsByYear[selectedYear]) {
                btn.disabled = true;
                btn.innerText = `No ${timelineUnit} Selected`;
                btn.classList.remove('added', 'remove');
                return;
            }

            const scene = plotsByYear[selectedYear];
            const isAdded = scene.sceneCharacters && scene.sceneCharacters.includes(selectedCharacterId);

            if (isAdded) {
                btn.innerText = `Remove Character from ${timelineUnit}`;
                btn.classList.remove('added');
                btn.classList.add('remove');
                btn.disabled = false;
            } else {
                btn.innerText = `Add Character to ${timelineUnit}`;
                btn.classList.remove('added', 'remove');
                btn.disabled = false;
            }
        }

        function addCharacterFromDetail() {
            if (!selectedCharacterId || !selectedYear) return;
            
            const scene = plotsByYear[selectedYear];
            const isAdded = scene.sceneCharacters && scene.sceneCharacters.includes(selectedCharacterId);
            
            if (isAdded) {
                // Remove character
                removeCharacterFromScene(selectedCharacterId);
            } else {
                // Add character
                addCharacterToScene(selectedCharacterId);
            }
            
            // Update button state and detail box (no fade/close)
            updateAddToEpisodeButton();
            showCharacterDetail(selectedCharacterId); // Refresh the appears-in list
        }

        function removeCharacterFromScene(charId) {
            if (!selectedYear || !plotsByYear[selectedYear]) return;
            
            const scene = plotsByYear[selectedYear];
            if (!scene.sceneCharacters) return;
            
            scene.sceneCharacters = scene.sceneCharacters.filter(id => id !== charId);
            
            saveData();
            renderTimeline();
        }

        function editCharacterFromDetail() {
            if (!selectedCharacterId) return;
            openCharacterEditor(selectedCharacterId);
        }

        function deleteCharacterFromDetail() {
            if (!selectedCharacterId) return;
            
            const char = characters.find(c => c.id === selectedCharacterId);
            if (!char) return;

            if (confirm(`Permanently delete ${char.name}?`)) {
                deleteCharacter(selectedCharacterId);
                closeCharacterDetail();
            }
        }

        // --- SCENE CHARACTER MANAGEMENT ---
        function addCharacterToScene(charId) {
            if (!selectedYear) return;
            
            ensureYearData(selectedYear);
            if (!plotsByYear[selectedYear].sceneCharacters) {
                plotsByYear[selectedYear].sceneCharacters = [];
            }

            if (!plotsByYear[selectedYear].sceneCharacters.includes(charId)) {
                plotsByYear[selectedYear].sceneCharacters.push(charId);
                saveData();
                renderSceneCharacters();
            }
        }

        function removeCharacterFromScene(charId) {
            if (!selectedYear) return;
            
            const scene = plotsByYear[selectedYear];
            if (scene && scene.sceneCharacters) {
                scene.sceneCharacters = scene.sceneCharacters.filter(id => id !== charId);
                saveData();
                renderSceneCharacters();
            }
        }

        function deleteCharacter(charId) {
            characters = characters.filter(c => c.id !== charId);
            
            // Remove from all scenes
            Object.keys(plotsByYear).forEach(year => {
                if (plotsByYear[year].sceneCharacters) {
                    plotsByYear[year].sceneCharacters = plotsByYear[year].sceneCharacters.filter(id => id !== charId);
                }
            });

            saveData();
            renderCharacterList();
            renderSceneCharacters();
        }

        async function renderSceneCharacters() {
            // This will update the Characters node to show linked characters
            const charNode = document.querySelector('.sub-node');
            if (!charNode) return;

            const scene = plotsByYear[selectedYear];
            if (!scene || !scene.sceneCharacters || scene.sceneCharacters.length === 0) {
                charNode.innerHTML = `
                    <div class="node-label">Characters</div>
                    <div style="font-size: 0.5rem; color: #444;">Click here to add characters/view Character Journal</div>
                `;
                return;
            }

            // Show character avatars in the node
            const charAvatars = scene.sceneCharacters.map(id => {
                const char = characters.find(c => c.id === id);
                if (!char) return '';
                
                const borderColor = char.color || '#333';
                
                return `<div class="scene-char-avatar" 
                    data-char-id="${id}"
                    data-char-image="${char.image || ''}"
                    style="border-color: ${borderColor};" 
                    onclick="openCharacterInfo(${id}); event.stopPropagation();"
                    onmouseenter="showCharacterPreview(${id}, event)"
                    onmouseleave="hideCharacterPreview()"
                    onmousemove="updateCharacterPreview(event)"></div>`;
            }).join('');

            charNode.innerHTML = `
                <div class="node-label">Characters</div>
                <div class="scene-characters-row">${charAvatars}</div>
            `;
            
            // Load images asynchronously
            await loadSceneCharacterImages();
        }
        
        async function loadSceneCharacterImages() {
            const avatars = document.querySelectorAll('.scene-char-avatar[data-char-image]');
            for (const avatar of avatars) {
                const imageRef = avatar.dataset.charImage;
                if (!imageRef) continue;
                
                if (imageRef.startsWith('indexeddb:')) {
                    const imageKey = imageRef.replace('indexeddb:', '');
                    try {
                        const blob = await getImage(imageKey);
                        if (blob) {
                            const blobUrl = URL.createObjectURL(blob);
                            avatar.style.backgroundImage = `url('${blobUrl}')`;
                            avatar.style.backgroundSize = 'cover';
                        }
                    } catch (error) {
                        console.error('Failed to load avatar image:', error);
                    }
                } else {
                    avatar.style.backgroundImage = `url('${imageRef}')`;
                    avatar.style.backgroundSize = 'cover';
                }
            }
        }

        // --- CHARACTER INFO PANEL (View Only) ---
        let viewingCharacterId = null;

        function openCharacterInfo(charId) {
            viewingCharacterId = charId;
            const char = characters.find(c => c.id === charId);
            if (!char) return;

            document.getElementById('info-char-name').innerText = char.name;
            
            // Avatar
            const avatar = document.getElementById('info-avatar');
            if (char.image) {
                avatar.style.backgroundImage = `url('${char.image}')`;
            } else {
                avatar.style.backgroundImage = 'none';
                avatar.style.backgroundColor = '#111';
            }
            avatar.style.borderColor = char.color || '#333';

            // Color badge
            document.getElementById('info-color-badge').style.backgroundColor = char.color || '#888';

            // Aliases
            const aliasesRow = document.getElementById('info-aliases-row');
            if (char.aliases && char.aliases.length > 0) {
                document.getElementById('info-aliases').innerText = char.aliases.join(', ');
                aliasesRow.style.display = 'flex';
            } else {
                aliasesRow.style.display = 'none';
            }

            // Status
            document.getElementById('info-status').innerText = char.status || 'Unknown';

            // Bio
            const bioRow = document.getElementById('info-bio-row');
            if (char.bio && char.bio.trim() !== '') {
                document.getElementById('info-bio').innerText = char.bio;
                bioRow.style.display = 'flex';
            } else {
                bioRow.style.display = 'none';
            }

            document.getElementById('character-info-overlay').style.display = 'flex';
        }

        function closeCharacterInfo() {
            document.getElementById('character-info-overlay').style.display = 'none';
            viewingCharacterId = null;
        }

        
        function handleDeleteYear() {
            if(!selectedYear || !confirm(`Delete ${timelineUnit} ${selectedYear} and all its data?`)) return;
            
            const idx = currentUniverse.years.indexOf(selectedYear);
            currentUniverse.years.splice(idx, 1);
            delete plotsByYear[selectedYear];
            
            if(currentUniverse.years.length > 0) {
                selectYear(currentUniverse.years[0]);
            } else {
                selectedYear = null;
                document.getElementById('node-group').style.display = 'none';
                renderTimeline();
                // Show empty state when last episode is deleted
                showEmptyStateMessage();
            }
            saveData();
        }

        // --- SAVE/LOAD SYSTEM ---
        function saveData() {
            if (!universeId) {
                console.warn('No universe ID - data will not persist');
                return;
            }
            
            const storageKey = `alphaline_universe_${universeId}`;
            
            try {
                // Get existing data to preserve atlas fields
                const existing = localStorage.getItem(storageKey);
                let existingData = {};
                if (existing) {
                    try {
                        existingData = JSON.parse(existing);
                    } catch (e) {
                        console.warn('Failed to parse existing data');
                    }
                }
                
                const dataToSave = JSON.stringify({
                    years: currentUniverse.years,
                    plots: plotsByYear,
                    characters: characters,
                    // Use glossary from localStorage if it's different (in case iframe updated it)
                    glossary: existingData.glossary && existingData.glossary.length > glossaryEntries.length 
                        ? existingData.glossary 
                        : glossaryEntries,
                    terminology: {
                        timelineUnit: timelineUnit,
                        subunitPlot: subunitPlot,
                        subunitEvent: subunitEvent
                    },
                    // Preserve atlas data
                    atlasImage: existingData.atlasImage || null,
                    atlasGridScale: existingData.atlasGridScale || 0,
                    atlasWaypoints: existingData.atlasWaypoints || [],
                    atlasTitle: existingData.atlasTitle || "World Atlas"
                });
                
                console.log(' Saving data:', {
                    years: currentUniverse.years.length,
                    characters: characters.length,
                    glossary: glossaryEntries.length,
                    glossaryTerms: glossaryEntries.map(e => e.term).join(', ')
                });
                
                // Calculate approximate size
                const dataSizeMB = new Blob([dataToSave]).size / 1024 / 1024;
                
                // Warn if approaching localStorage limits (typically 5-10MB)
                if (dataSizeMB > 5) {
                    console.warn(` Large data size: ${dataSizeMB.toFixed(2)}MB. May exceed browser storage limits.`);
                }
                
                localStorage.setItem(storageKey, dataToSave);
                console.log(' Data saved successfully');
                
                // Update last edited timestamp in universes list
                const universes = JSON.parse(localStorage.getItem('alphaline_universes') || '[]');
                const universeEntry = universes.find(u => u.id === parseInt(universeId));
                if (universeEntry) {
                    const date = new Date().toLocaleDateString(undefined, {year:'numeric', month:'short', day:'numeric'}).toUpperCase();
                    universeEntry.lastEdited = date;
                    localStorage.setItem('alphaline_universes', JSON.stringify(universes));
                }
                
                document.getElementById('save-status').innerText = 'CHANGES SYNCED';
                
                // Brief flash to show save
                setTimeout(() => {
                    document.getElementById('save-status').style.color = '#4a4';
                }, 100);
                setTimeout(() => {
                    document.getElementById('save-status').style.color = '#444';
                }, 2000);
            } catch (e) {
                console.error('Failed to save data:', e);
                
                // Check if it's a quota exceeded error
                if (e.name === 'QuotaExceededError' || e.code === 22) {
                    document.getElementById('save-status').innerText = 'SAVE FAILED - STORAGE FULL';
                    document.getElementById('save-status').style.color = '#f44';
                    
                    alert(' Browser Storage Limit Reached\n\n' +
                          'Your workspace has exceeded the browser storage limit (5-10MB).\n\n' +
                          ' BEST SOLUTION:\n' +
                          '1. Use image URLs instead of uploading files\n' +
                          '2. Upload images to Imgur, Google Photos, etc.\n' +
                          '3. Copy the image URL\n' +
                          '4. Paste into the "Or URL" field\n\n' +
                          'This stores NO data in browser - unlimited capacity!\n\n' +
                          ' NOTE: Your text data is saved. Only new uploads failed.');
                } else {
                    document.getElementById('save-status').innerText = 'SAVE FAILED';
                    document.getElementById('save-status').style.color = '#f44';
                }
                
                setTimeout(() => {
                    document.getElementById('save-status').style.color = '#444';
                }, 5000);
            }
        }

        function loadData() {
            if (!universeId) {
                console.warn('No universe ID - cannot load data');
                renderTimeline();
                return;
            }
            
            const storageKey = `alphaline_universe_${universeId}`;
            const saved = localStorage.getItem(storageKey);
            
            console.log(' Loading data for universe:', universeId);
            
            if(saved) {
                try {
                    const data = JSON.parse(saved);
                    currentUniverse.years = data.years || [];
                    plotsByYear = data.plots || {};
                    characters = data.characters || [];
                    glossaryEntries = data.glossary || [];
                    
                    // FORCE RESET: All events MUST use correct widths - no exceptions
                    // This fixes any legacy data with wrong sizes
                    Object.keys(plotsByYear).forEach(year => {
                        if (plotsByYear[year].plots) {
                            plotsByYear[year].plots.forEach(plot => {
                                if (plot.events) {
                                    plot.events.forEach(ev => {
                                        // ALWAYS reset to correct values
                                        ev.textWidth = 562;
                                        ev.imageWidth = 460;
                                    });
                                }
                            });
                        }
                    });
                    
                    console.log(' Loaded glossary entries:', {
                        count: glossaryEntries.length,
                        entries: glossaryEntries.map(e => e.term).join(', ')
                    });
                    
                    // Load terminology from universe data (per-universe, not shared)
                    if (data.terminology) {
                        timelineUnit = data.terminology.timelineUnit || "Episode";
                        subunitPlot = data.terminology.subunitPlot || "Scene";
                        subunitEvent = data.terminology.subunitEvent || "Event";
                    }
                    
                    if(currentUniverse.years.length > 0) {
                        // Don't auto-select - let user choose
                        // Just show the landing prompt
                        showEmptyStateMessage();
                    } else {
                        // Show empty state message
                        showEmptyStateMessage();
                    }
                } catch(e) {
                    console.error('Failed to load saved data:', e);
                }
            } else {
                console.warn('No saved data found for universe:', universeId);
                // Show empty state for new universe
                showEmptyStateMessage();
            }
            
            renderTimeline();
            updateTimelineUnitUI();
            updateSubunitUI();
        }
        
        function showEmptyStateMessage() {
            document.getElementById('landing-message').classList.add('visible');
            document.getElementById('timeline-hud').classList.add('glow-pulse');
        }
        
        function hideEmptyStateMessage() {
            document.getElementById('landing-message').classList.remove('visible');
            document.getElementById('timeline-hud').classList.remove('glow-pulse');
        }

        // Initialize on page load
        initTrashZone(); // Setup trash zone ONCE
        restoreTimelineHudState(); // Restore timeline visibility state
        loadThemePreference(); // Load saved theme
        loadData();
        
        // Initialize timeline button tooltips
        initTimelineButtonTooltips();
        
        // Send message to parent to hide header/footer (workspace mode)
        window.parent.postMessage('RETRACT_FRAME', '*');
        
        // FAILSAFE: Save data before page unloads
        window.addEventListener('beforeunload', (event) => {
            console.log(' Page unloading - saving data...');
            saveData();
        });
        
        // Character preview tooltip
        let characterPreviewTimeout;
        
        async function showCharacterPreview(charId, event) {
            clearTimeout(characterPreviewTimeout);
            
            const char = characters.find(c => c.id === charId);
            if (!char) return;
            
            // Find which episodes this character appears in
            const appearingEpisodes = [];
            Object.keys(plotsByYear).forEach(year => {
                const scene = plotsByYear[year];
                if (scene.sceneCharacters && scene.sceneCharacters.includes(charId)) {
                    appearingEpisodes.push(year);
                }
            });
            
            // Truncate bio to 150 characters
            let bioText = char.bio || 'No biography added.';
            if (bioText.length > 150) {
                bioText = bioText.substring(0, 150) + '...';
            }
            
            // Build avatar image
            let avatarHTML = '';
            if (char.image) {
                let imageSrc = char.image;
                
                // Check if IndexedDB reference
                if (char.image.startsWith('indexeddb:')) {
                    const imageKey = char.image.replace('indexeddb:', '');
                    try {
                        const blob = await getImage(imageKey);
                        if (blob) {
                            imageSrc = URL.createObjectURL(blob);
                        }
                    } catch (error) {
                        console.error('Failed to load character avatar:', error);
                    }
                }
                
                avatarHTML = `
                    <div style="width: 60px; height: 60px; border-radius: 50%; overflow: hidden; border: 2px solid ${char.color || '#888'}; margin-bottom: 10px; background: #000;">
                        <img src="${imageSrc}" style="width: 100%; height: 100%; object-fit: cover;">
                    </div>
                `;
            } else {
                avatarHTML = `
                    <div style="width: 60px; height: 60px; border-radius: 50%; border: 2px solid ${char.color || '#888'}; margin-bottom: 10px; background: #000; display: flex; align-items: center; justify-content: center; color: #333; font-size: 0.6rem;">
                        No Image
                    </div>
                `;
            }
            
            const tooltip = document.getElementById('character-preview-tooltip');
            tooltip.innerHTML = `
                ${avatarHTML}
                <div class="preview-tooltip-header">${char.name}</div>
                <div class="preview-tooltip-subtext">${char.status || 'Unknown'}</div>
                <div class="preview-tooltip-bio">${bioText}</div>
                <div class="preview-tooltip-episodes">
                    <span class="preview-tooltip-label">Appears in ${timelineUnit}(s):</span> 
                    ${appearingEpisodes.length > 0 ? appearingEpisodes.sort((a,b) => a-b).join(', ') : 'None'}
                </div>
            `;
            
            characterPreviewTimeout = setTimeout(() => {
                tooltip.classList.add('show');
            }, 300);
            
            updateTooltipPosition(tooltip, event);
        }
        
        function hideCharacterPreview() {
            clearTimeout(characterPreviewTimeout);
            const tooltip = document.getElementById('character-preview-tooltip');
            tooltip.classList.remove('show');
        }
        
        function updateCharacterPreview(event) {
            const tooltip = document.getElementById('character-preview-tooltip');
            if (tooltip.classList.contains('show')) {
                updateTooltipPosition(tooltip, event);
            }
        }
        
        // Episode preview tooltip
        let episodePreviewTimeout;
        
        function showEpisodePreview(year, event) {
            clearTimeout(episodePreviewTimeout);
            
            const scene = plotsByYear[year];
            if (!scene) return;
            
            const episodeTitle = scene.episodeTitle || `${timelineUnit} ${year}`;
            let synopsis = scene.synopsis || 'No synopsis added.';
            if (synopsis.length > 150) {
                synopsis = synopsis.substring(0, 150) + '...';
            }
            
            // Get character names
            const characterNames = (scene.sceneCharacters || [])
                .map(id => {
                    const char = characters.find(c => c.id === id);
                    return char ? char.name : null;
                })
                .filter(name => name)
                .join(', ');
            
            const tooltip = document.getElementById('episode-preview-tooltip');
            tooltip.innerHTML = `
                <div class="preview-tooltip-header">${timelineUnit} ${year}: ${episodeTitle}</div>
                <div class="preview-tooltip-bio">${synopsis}</div>
                <div class="preview-tooltip-episodes">
                    <span class="preview-tooltip-label">Featuring:</span> 
                    ${characterNames || 'No characters added'}
                </div>
            `;
            
            episodePreviewTimeout = setTimeout(() => {
                tooltip.classList.add('show');
            }, 300);
            
            updateTooltipPosition(tooltip, event);
        }
        
        function hideEpisodePreview() {
            clearTimeout(episodePreviewTimeout);
            const tooltip = document.getElementById('episode-preview-tooltip');
            tooltip.classList.remove('show');
        }
        
        function updateEpisodePreview(event) {
            const tooltip = document.getElementById('episode-preview-tooltip');
            if (tooltip.classList.contains('show')) {
                updateTooltipPosition(tooltip, event);
            }
        }
        
        function updateTooltipPosition(tooltip, event) {
            const offsetX = 15;
            const offsetY = 15;
            const tooltipRect = tooltip.getBoundingClientRect();
            
            let x = event.clientX + offsetX;
            let y = event.clientY + offsetY;
            
            // Keep tooltip on screen
            if (x + tooltipRect.width > window.innerWidth) {
                x = event.clientX - tooltipRect.width - offsetX;
            }
            if (y + tooltipRect.height > window.innerHeight) {
                y = event.clientY - tooltipRect.height - offsetY;
            }
            
            tooltip.style.left = x + 'px';
            tooltip.style.top = y + 'px';
        }
        
        // Character name highlighting in text
        function highlightCharacterNames(text) {
            if (!text) return text;
            
            let result = text;
            
            // First apply glossary highlighting
            result = highlightGlossaryTerms(result);
            
            // Then apply character highlighting
            if (characters.length > 0) {
                // Sort characters by name length (longest first) to avoid partial matches
                const sortedChars = [...characters].sort((a, b) => b.name.length - a.name.length);
                
                sortedChars.forEach(char => {
                    if (!char.name || char.name === "Unnamed Character") return;
                    
                    // Case-insensitive regex with word boundaries
                    const regex = new RegExp(`\\b(${char.name})\\b`, 'gi');
                    
                    result = result.replace(regex, (match, p1, offset) => {
                        const id = `char_${char.id}_${offset}`;
                        return `<span class="char-name-highlight" id="${id}" style="color: ${char.color}; border-color: ${char.color};" data-char-id="${char.id}">${match}</span>`;
                    });
                });
            }
            
            return result;
        }
        
        function attachCharacterNameHandlers() {
            // Attach hover handlers to all highlighted character names
            // Use cloning to remove old listeners
            document.querySelectorAll('.char-name-highlight').forEach(span => {
                const charId = parseInt(span.dataset.charId);
                if (!charId) return;
                
                // Remove old listeners by cloning node
                const newSpan = span.cloneNode(true);
                span.parentNode.replaceChild(newSpan, span);
                
                // Add fresh listeners
                newSpan.addEventListener('mouseenter', (e) => showCharacterPreview(charId, e));
                newSpan.addEventListener('mouseleave', () => hideCharacterPreview());
                newSpan.addEventListener('mousemove', (e) => updateCharacterPreview(e));
            });
            
            // Also attach glossary handlers
            attachGlossaryHandlers();
        }
        
        // --- GLOSSARY SYSTEM ---
        let glossaryEntries = [];
        
        function toggleLorePanel() {
            const loreNode = document.getElementById('lore-node');
            const loreToggle = document.getElementById('lore-toggle');
            
            loreNode.classList.toggle('hidden');
            loreToggle.classList.toggle('panel-hidden');
        }
        
        function openGlossary() {
            const overlay = document.getElementById('glossary-overlay');
            const iframe = document.getElementById('glossary-iframe');
            
            // Load glossary in iframe with universe ID
            iframe.src = `glossary.html?id=${universeId}`;
            overlay.classList.add('active');
        }
        
        function closeGlossaryOverlay() {
            console.log(' Closing glossary overlay');
            const overlay = document.getElementById('glossary-overlay');
            overlay.classList.remove('active');
            
            console.log(' Before reload - glossary entries:', glossaryEntries.length);
            
            // Reload data to get latest glossary entries from localStorage
            // (Glossary iframe has already saved its data)
            loadData();
            
            console.log(' After reload - glossary entries:', glossaryEntries.length);
        }
        
        // --- STATISTICS SYSTEM ---
        function openStatistics() {
            const overlay = document.getElementById('statistics-overlay');
            const iframe = document.getElementById('statistics-iframe');
            
            // Load statistics in iframe with universe ID and episode
            iframe.src = `statistics.html?id=${universeId}&episode=${selectedYear}`;
            overlay.classList.add('active');
        }
        
        function closeStatisticsOverlay() {
            const overlay = document.getElementById('statistics-overlay');
            overlay.classList.remove('active');
        }
        
                // --- ATLAS SYSTEM ---
        function openAtlas() {
            const overlay = document.getElementById('atlas-overlay');
            const iframe = document.getElementById('atlas-iframe');
            iframe.src = `atlas.html?id=${universeId}`;
            overlay.classList.add('active');
        }
        
        function closeAtlasOverlay() {
            const overlay = document.getElementById('atlas-overlay');
            overlay.classList.remove('active');
        }
        

        
        // Listen for messages from statistics iframe
        window.addEventListener('message', (event) => {
            if (event.data.type === 'CLOSE_GLOSSARY') {
                closeGlossaryOverlay();
            } else if (event.data.type === 'CLOSE_STATISTICS') {
                closeStatisticsOverlay();
            } else if (event.data.type === 'CLOSE_ATLAS') {
                closeAtlasOverlay();
            } else if (event.data.type === 'ATLAS_UPDATED') {
                // Atlas has already saved its data to localStorage
                // Just reload to sync our copy
                loadData();
            } else if (event.data.type === 'GLOSSARY_UPDATED') {
                // Update local glossary entries
                const newEntries = event.data.data || [];
                console.log(' GLOSSARY_UPDATED received:', {
                    count: newEntries.length,
                    terms: newEntries.map(e => e.term).join(', ')
                });
                glossaryEntries = newEntries;
                // Save immediately when glossary is updated
                saveData();
                // Re-render to update highlighting
                if (selectedYear) {
                    renderPlotStack();
                }
            }
        });
        
        // Highlight glossary terms in text
        function highlightGlossaryTerms(text) {
            if (!text || glossaryEntries.length === 0) return text;
            
            // Sort by length (longest first) to avoid partial matches
            const sortedEntries = [...glossaryEntries].sort((a, b) => {
                const aLen = Math.max(a.name?.length || 0, ...(a.aliases || []).map(al => al.length));
                const bLen = Math.max(b.name?.length || 0, ...(b.aliases || []).map(al => al.length));
                return bLen - aLen;
            });
            
            let result = text;
            
            sortedEntries.forEach(entry => {
                if (!entry.name) return;
                
                // Build list of terms to match (name + aliases)
                const terms = [entry.name];
                if (entry.aliases) {
                    terms.push(...entry.aliases);
                }
                
                terms.forEach(term => {
                    if (!term) return;
                    
                    // Escape special regex characters
                    const escapedTerm = term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    
                    // Case-insensitive regex with word boundaries
                    // Negative lookahead to avoid matching inside already-highlighted spans
                    const regex = new RegExp(`\\b(${escapedTerm})\\b(?![^<]*<\\/span>)`, 'gi');
                    
                    result = result.replace(regex, (match) => {
                        // Check if this match is already inside a span
                        const beforeMatch = result.substring(0, result.indexOf(match));
                        const openSpans = (beforeMatch.match(/<span/g) || []).length;
                        const closeSpans = (beforeMatch.match(/<\/span>/g) || []).length;
                        
                        // If we're inside a span, don't replace
                        if (openSpans > closeSpans) {
                            return match;
                        }
                        
                        return `<span class="glossary-term-highlight" 
                                     style="border-color: ${entry.color || '#888'}; color: ${entry.color || '#fff'};" 
                                     data-glossary-id="${entry.id}"
                                     data-glossary-name="${entry.name}">${match}</span>`;
                    });
                });
            });
            
            return result;
        }
        
        function attachGlossaryHandlers() {
            // Attach hover handlers to all highlighted glossary terms
            // Use event delegation or remove old listeners by cloning
            document.querySelectorAll('.glossary-term-highlight').forEach(span => {
                const glossaryId = parseInt(span.dataset.glossaryId);
                if (!glossaryId) return;
                
                // Remove old listeners by cloning node (clean slate)
                const newSpan = span.cloneNode(true);
                span.parentNode.replaceChild(newSpan, span);
                
                // Add fresh listeners
                newSpan.addEventListener('mouseenter', (e) => showGlossaryPreview(glossaryId, e));
                newSpan.addEventListener('mouseleave', () => hideGlossaryPreview());
                newSpan.addEventListener('mousemove', (e) => updateGlossaryPreview(e));
            });
        }
        
        // Glossary preview tooltip
        let glossaryPreviewTimeout;
        
        async function showGlossaryPreview(glossaryId, event) {
            clearTimeout(glossaryPreviewTimeout);
            
            const entry = glossaryEntries.find(e => e.id === glossaryId);
            if (!entry) return;
            
            glossaryPreviewTimeout = setTimeout(async () => {
                const tooltip = document.getElementById('glossary-preview-tooltip');
                
                // Load image if needed
                let imageSrc = null;
                if (entry.image) {
                    if (entry.image.startsWith('indexeddb:')) {
                        const imageKey = entry.image.replace('indexeddb:', '');
                        try {
                            const blob = await getImage(imageKey);
                            if (blob) {
                                imageSrc = URL.createObjectURL(blob);
                            }
                        } catch (error) {
                            console.error('Failed to load glossary image:', error);
                        }
                    } else {
                        imageSrc = entry.image;
                    }
                }
                
                // Build avatar HTML (circular like character)
                let avatarHTML = '';
                if (imageSrc) {
                    avatarHTML = `
                        <div style="width: 60px; height: 60px; border-radius: 50%; overflow: hidden; border: 2px solid ${entry.color || '#888'}; margin-bottom: 10px; background: #000;">
                            <img src="${imageSrc}" style="width: 100%; height: 100%; object-fit: cover;">
                        </div>
                    `;
                } else {
                    avatarHTML = `
                        <div style="width: 60px; height: 60px; border-radius: 50%; border: 2px solid ${entry.color || '#888'}; margin-bottom: 10px; background: #000; display: flex; align-items: center; justify-content: center; color: #333; font-size: 0.6rem;">
                            No Image
                        </div>
                    `;
                }
                
                // Truncate description
                const description = entry.description || 'No description';
                const truncated = description.length > 150 ? description.substring(0, 150) + '...' : description;
                
                tooltip.innerHTML = `
                    ${avatarHTML}
                    <div class="glossary-preview-name" style="color: ${entry.color || '#fff'}">${entry.name}</div>
                    <div class="glossary-preview-type">${entry.type || 'Item'}</div>
                    <div class="glossary-preview-description">${truncated}</div>
                `;
                
                tooltip.classList.add('show');
                updateGlossaryPreview(event);
            }, 300);
        }
        
        function hideGlossaryPreview() {
            clearTimeout(glossaryPreviewTimeout);
            const tooltip = document.getElementById('glossary-preview-tooltip');
            tooltip.classList.remove('show');
        }
        
        function updateGlossaryPreview(event) {
            const tooltip = document.getElementById('glossary-preview-tooltip');
            updateTooltipPosition(tooltip, event);
        }
        
        // Timeline button tooltips
        function initTimelineButtonTooltips() {
            const buttons = document.querySelectorAll('.timeline-btn[data-tooltip]');
            const tooltip = document.getElementById('timeline-btn-tooltip');
            let tooltipTimeout;
            
            buttons.forEach(btn => {
                btn.addEventListener('mouseenter', (e) => {
                    clearTimeout(tooltipTimeout);
                    tooltipTimeout = setTimeout(() => {
                        tooltip.textContent = btn.dataset.tooltip;
                        tooltip.style.left = e.clientX + 15 + 'px';
                        tooltip.style.top = e.clientY + 15 + 'px';
                        tooltip.classList.add('show');
                    }, 100); // 0.1s delay
                });
                
                btn.addEventListener('mouseleave', () => {
                    clearTimeout(tooltipTimeout);
                    tooltip.classList.remove('show');
                });
                
                btn.addEventListener('mousemove', (e) => {
                    if (tooltip.classList.contains('show')) {
                        tooltip.style.left = e.clientX + 15 + 'px';
                        tooltip.style.top = e.clientY + 15 + 'px';
                    }
                });
            });
        }
        
        // Allow Enter key to confirm year modal
        document.getElementById('year-input').addEventListener('keypress', (e) => {
            if(e.key === 'Enter') confirmNewYear();
        });
        
        // Allow Enter key to confirm event image URL
        document.getElementById('event-image-url').addEventListener('keypress', (e) => {
            if(e.key === 'Enter') confirmEventImage();
        });
    </script>
</body>
</html>